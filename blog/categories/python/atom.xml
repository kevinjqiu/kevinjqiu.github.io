<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python, | Qiu's Quibble]]></title>
  <link href="http://kevinjqiu.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://kevinjqiu.github.io/"/>
  <updated>2015-04-30T23:56:27-04:00</updated>
  <id>http://kevinjqiu.github.io/</id>
  <author>
    <name><![CDATA[Kevin Jing Qiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Use Python decorator to curry functions]]></title>
    <link href="http://kevinjqiu.github.io/2010/10/22/use-python-decorator-to-curry-functions/"/>
    <updated>2010-10-22T20:06:00-04:00</updated>
    <id>http://kevinjqiu.github.io/2010/10/22/use-python-decorator-to-curry-functions</id>
    <content type="html"><![CDATA[<p>It&rsquo;s been a while since the last time I wrote about Python. This morning, I was listening to a podcast on my way to work. They were discussing functional programming and dynamic languages&hellip;I learned Python before I went into Computer Science, and then I learned about functional programming and through learning of Scala and Clojure, my functional programming concepts have been enriched. As I was listening, it suddenly appeared to me that there isn&rsquo;t a way in Python to <a href="http://en.wikipedia.org/wiki/Currying">curry</a> a function. Not that it&rsquo;s critical to everyday development, but wouldn&rsquo;t it be neat if I can curry a function in Python?</p>

<p>Then the hosts of the podcast discussed how dynamic languages are so flexible that you can pretty much do anything to it. &ldquo;You can take a function as parameter, return a function from a function, and so on.&rdquo; Hey, isn&rsquo;t that what Python&rsquo;s <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">decorator</a> can do? I learned decorators before, but I haven&rsquo;t used it beyond the scope of creating properties and certainly haven&rsquo;t written any decorators. I thought this would be a good exercise for learning decorators.</p>

<p>Here&rsquo;s a simple example of what function currying: suppose you have a method</p>

<pre><code class="python">def add(x,y):
  return x+y
</code></pre>

<p>Then calling <code>add(1,2)</code> should be the same as <code>add(1)(2)</code>. <code>add(1)</code> is what they call a partially applied function. It&rsquo;s a function that takes one parameter.</p>

<p>Our goal here is to write a decorator &ldquo;curried&rdquo; that takes a function with n parameters and transform it in a way that can be applied n times and get the final result.</p>

<p>We&rsquo;ll start with unit tests first:</p>

<pre><code class="python">import unittest

class CurryTest(unittest.TestCase):

    def test_with_no_args(self):
        @curried
        def do_nothing():
            return ""
        self.assertEquals("", do_nothing())

    def test_with_int_args(self):
        @curried
        def add_int(x,y):
            return x+y
        self.assertEquals(3, add_int(1)(2))
    def test_with_str_args(self):
        @curried
        def add_str(x,y):
            return "%s%s"%(x,y)
        self.assertEquals("ab", add_str("a")("b"))
</code></pre>

<p>So we make sure that a currying on a function takes no parameter is valid but should be a pass through, and also the &ldquo;curried&rdquo; decorator can be applied to any function with arguments (excluding positional arguments and keyword arguments)</p>

<p>A decorator is simply a function that takes a function as parameter:
<code>python
def curried(fn):
  pass
</code>
and <code>@curried</code> is simply a syntactic sugar for:</p>

<pre><code class="python">def fn(...): ...
fn=curried(fn)
</code></pre>

<p>So, now we can write <code>curried</code> decorator.
To make the test for function with no argument pass, in <code>curried()</code> function, we can test to see if fn has arguments. Python&rsquo;s standard library provides <code>inspect.getargspec</code> method:</p>

<pre><code class="python">def curried(fn):
  argspec = inspect.getargspec(fn)
  if len(argspec.args)==0:
    return fn
  else:
    # later
</code></pre>

<p>Now the first test passes.</p>

<p>For the other two cases, here&rsquo;s the strategy. In Python, when a class defines <code>__call__</code> method, the instance of that class is said to be &ldquo;callable&rdquo;. For instance:</p>

<pre><code class="python">class A(object):
  def __call__(self, arg):
    return arg

f=A()
f("echo")  # this gives you "echo"
</code></pre>

<p>This is very similar to Scala&rsquo;s <code>apply()</code> function. Now that we have this in our inventory, we can define a <code>PartialFunction</code> class, take all the required parameters of the original function, and allow them to be applied one at a time. So the <code>__call__</code> method of PartialFunc will look like this:</p>

<pre><code class="python">def __call__(self, value):
  # Xxx
</code></pre>

<p>If all the required parameters are passed in, <code>PartialFunc</code> should evaluate the original function with the complete argument list. Otherwise, <code>PartialFunc</code> stores the parameter in an instance variable, and returns itself.</p>

<p>Here&rsquo;s the complete code:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">PartialFunc</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="err">&lt;</span><span class="nf">strong</span><span class="o">&gt;</span><span class="n">init</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">argspec</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">argspec</span> <span class="o">=</span> <span class="n">argspec</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">[]</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
</span><span class='line'>    <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
</span><span class='line'>        <span class="n">arglist</span> <span class="o">=</span> <span class="s">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&quot;self.args[</span><span class="si">%d</span><span class="s">]&quot;</span><span class="o">%</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">))])</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&quot;self.fn(&quot;</span> <span class="o">+</span> <span class="n">arglist</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="ow">and</span> <span class="n">the</span> <span class="n">curried</span> <span class="n">decorator</span><span class="p">:</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">curried</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span><span class='line'>    <span class="n">argspec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">fn</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">PartialFunc</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">argspec</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>It&rsquo;s pretty straightforward. When the parameters are complete, I construct a python statement that calls the original function with the complete argument list, and then pass the statement into an eval statement. I know evals are evil, but I can&rsquo;t find a way in Python to dynamically change the signature of the original method and make it accept a variable length argument (varargs).</p>

<p>So this is it. It&rsquo;s quite simple. Python methods can have varargs and keyword args, the situation gets a little more complicated. The thing is, both varargs and keyword args are not mandatory, so it&rsquo;s hard for the curried function to know whether the argument list has been completed&hellip;Also, if you take default values into account, it could get even more complicated.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enable Auto-complete in a PDB session]]></title>
    <link href="http://kevinjqiu.github.io/2009/06/12/enable-auto-complete-in-a-pdb-session/"/>
    <updated>2009-06-12T09:25:00-04:00</updated>
    <id>http://kevinjqiu.github.io/2009/06/12/enable-auto-complete-in-a-pdb-session</id>
    <content type="html"><![CDATA[<p>EDIT: 2012-06-19 There are so many other much better options now that renders recipe obsolete. See <a href="https://bitbucket.org/antocuni/pdb/src">pdb++</a> or <a href="https://github.com/gotcha/ipdb">ipdb</a></p>

<p>Pretty simple actuallyâ€¦Just put the following code in <code>~/.pdbrc</code> and then you can use the Tab key during a PDB session to see the available attributes of the current context.</p>

<pre><code class="python">import rlcompleter
pdb.Pdb.complete=rlcompleter.Completer(locals()).complete
</code></pre>
]]></content>
  </entry>
  
</feed>
