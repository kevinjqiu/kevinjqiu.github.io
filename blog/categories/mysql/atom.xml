<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mysql | Qiu's Quibble]]></title>
  <link href="http://kevinjqiu.github.io/blog/categories/mysql/atom.xml" rel="self"/>
  <link href="http://kevinjqiu.github.io/"/>
  <updated>2015-09-04T00:04:11-04:00</updated>
  <id>http://kevinjqiu.github.io/</id>
  <author>
    <name><![CDATA[Kevin Jing Qiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MySQL EXPLAIN explained]]></title>
    <link href="http://kevinjqiu.github.io/2014/11/27/mysql-explain-explained/"/>
    <updated>2014-11-27T00:56:59-05:00</updated>
    <id>http://kevinjqiu.github.io/2014/11/27/mysql-explain-explained</id>
    <content type="html"><![CDATA[<p>Below is my notes from watching the <a href="https://www.youtube.com/watch?v=ZoLoIFW1H6g">MySQL&rsquo;s EXPLAIN demystified</a> webinar.  All credits go to Baron Schwartz for this excellent intro to MySQL&rsquo;s query explain.</p>

<h2>How does MySQL execute queries?</h2>

<ul>
<li>SQL => Parse Tree => Execution plan</li>
<li>The execution plan is a data structure, not byte-code</li>
<li>The executor makes storage engine calls</li>
</ul>


<h2>Execution plan</h2>

<p>&ldquo;Deep left tree&rdquo; &ndash; always</p>

<h2>Explain output columns</h2>

<h3>id</h3>

<ul>
<li>which <code>SELECT</code> the row belongs to</li>
<li>Labelled sequentially</li>
<li>complex select:

<ul>
<li>subquery: numbered according to the position in SQL text</li>
<li>derived: executed as a temporary table</li>
<li>union: fill a temp table, then read out with a <code>NULL</code> id</li>
</ul>
</li>
</ul>


<h3>select_type</h3>

<ul>
<li>simple: there&rsquo;s only one <code>SELECT</code> in the whole query, <code>select_type</code> is <code>PRIMARY</code></li>
<li>complex:

<ul>
<li>subquery: numbered according to the position in SQL text</li>
<li>derived: executed as a temporary table</li>
<li>union: fill a temp table, then read out with a <code>NULL</code> id</li>
</ul>
</li>
</ul>


<h3>table</h3>

<ul>
<li>table name or alias</li>
<li><code>&lt;DerivedN&gt;</code>, <code>N</code> correspond to <code>id</code></li>
<li><code>&lt;unionM,N&gt;</code>, <code>M</code>, <code>N</code> correspond to <code>id</code></li>
</ul>


<h3>type</h3>

<ul>
<li>describes how MySQL will access the rows</li>
<li>Possible values:

<ul>
<li>ALL: table scan</li>
<li>index: full index scan</li>
<li>range: range of an index</li>
<li>ref: value as a reference to look into an index if rows in the index match the value</li>
<li>eq_ref: like <code>ref</code> but unique (unique index or PK)</li>
<li>const</li>
<li>system: does not require accessing a table, e.g., <code>MAX(col)</code></li>
<li>NULL: no table involved, e.g., <code>SELECT 1</code></li>
</ul>
</li>
</ul>


<h3>Index-related columns (possible_kes, key, key_len)</h3>

<ul>
<li>possible_keys: which indexes were considered?</li>
<li>key: which indexes did the optimizer choose?</li>
<li>key_len: how many bytes of the index will be used? if key_len less than the index (e.g., compound index), that means MySQL didn&rsquo;t use the whole index</li>
</ul>


<h3>ref</h3>

<ul>
<li>The source of values used for lookups</li>
<li><code>const</code></li>
<li><code>NULL</code> means not looking for a particular value for that table</li>
</ul>


<h3>rows</h3>

<ul>
<li>Estimated rows to examine in the table/index</li>
</ul>


<h3>extra</h3>

<ul>
<li>Using index

<ul>
<li>If the query only involve columns that are in the index, MySQL can query directly against the index, without looking at the table at all</li>
<li>Hitting a index (<code>type</code>) does not necessarily mean <code>Using index</code>.  If not <code>Using index</code>, MySQL got the indexed value but still has to go back and look it up in the table for other columns, which may result in lots of random IO (slow)</li>
</ul>
</li>
<li>Using where

<ul>
<li>Post-filter using the where clause</li>
</ul>
</li>
<li>Using temporary

<ul>
<li>The query is going to create an implicit temporary table</li>
</ul>
</li>
<li>Using filesort

<ul>
<li>Sorting in memory, if it doesn&rsquo;t fit, then write to file</li>
<li>Algorithm is quick sort</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
