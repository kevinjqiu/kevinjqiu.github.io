<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Qiu&#39;s Quibble</title>
    <link>http://blog.idempotent.ca/categories/sudoku/index.xml</link>
    <description>Recent content on Qiu&#39;s Quibble</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.idempotent.ca/categories/sudoku/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Write sudoku solver in Clojure</title>
      <link>http://blog.idempotent.ca/2011/03/02/write-sudoku-solver-in-clojure/</link>
      <pubDate>Wed, 02 Mar 2011 20:00:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2011/03/02/write-sudoku-solver-in-clojure/</guid>
      <description>&lt;p&gt;&amp;hellip;yeah, because the world just needs another &lt;a href=&#34;http://en.wikipedia.org/wiki/Sudoku&#34;&gt;Sudoku&lt;/a&gt; solver. Well, I&amp;rsquo;m not trying to solve world hunger with it, but just an attempt to practice &lt;a href=&#34;http://clojure.org&#34;&gt;clojure&lt;/a&gt;, I took (read: stole) Peter Norvig&amp;rsquo;s &lt;a href=&#34;http://norvig.com/sudoku.html&#34;&gt;sudoku solver&lt;/a&gt; algorithm (written in Python) and adapted it into Clojure. I put it up on Github under &lt;a href=&#34;https://github.com/kevinjqiu/sudoku-clj&#34;&gt;sudoku-clj&lt;/a&gt;. The algorithm itself isn&amp;rsquo;t &lt;em&gt;that&lt;/em&gt; hard to understand. The porting to a lisp-y syntax made the code a little longer than its Python counterpart. I&amp;rsquo;m sure seasoned Lisp/Clojure users can point out dozens of places where more idiomatic/succinct syntax can be used (If you happen to be one, do tell, by the way).&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a few things I noticed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mutable states in clojure are captured using &lt;code&gt;ref&lt;/code&gt;s. The object itself (in this case, the grid, which is a hash map) doesn&amp;rsquo;t mutate, but the reference is changed to point to different grid objects that represent a configuration at a given step.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clojure sequences are Lazy. A few times I tried to print out the current state (remaining digits) of the square, but if you simply do &lt;code&gt;(println seq)&lt;/code&gt;, you will get a Java-ish &lt;code&gt;toString()&lt;/code&gt; output of the sequence object. You need to force the lazy sequence to be evaluated by &lt;code&gt;(println (apply str seq))&lt;/code&gt;. Needless to say, you lose the advantage of lazy sequences, so use it sparingly.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python&amp;rsquo;s list comprehension syntax is fabulous. Clojure&amp;rsquo;s counterpart for comprehension doesn&amp;rsquo;t feel as elegent, nor is map a function onto a sequence to achieve that (the way I used it)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.idempotent.ca/2011/02/11/cake-the-yummy-clojure-build-system/&#34;&gt;Cake&lt;/a&gt; is yummy!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The performance isn&amp;rsquo;t great&amp;hellip;I must have done something wrong, but the easy sudoku grid took about 2 seconds (with the JVM already booted), while the Python algorithm solves it in a fraction of a second.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Because assign/eliminate are mutually recursive, my current implementation uses the naive way of doing recursion, i.e., let the stack grow. Clojure has a function &lt;code&gt;trampoline&lt;/code&gt;, which adds a level of indirection that applies to mutually recursive functions. It uses &lt;code&gt;recur&lt;/code&gt; at tail end position (basically translates the recursive calls into loops) which doesn&amp;rsquo;t fill your process&amp;rsquo;s stack. It might not be obvious (to me anyways) how one can do that with a few levels of function calls in between assign/eliminate, but I&amp;rsquo;m sure there&amp;rsquo;s a way&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>