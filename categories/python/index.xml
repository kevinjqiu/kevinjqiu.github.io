<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Qiu&#39;s Quibble</title>
    <link>http://blog.idempotent.ca/categories/python/</link>
    <description>Recent content in Python on Qiu&#39;s Quibble</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 03 Sep 2015 22:16:36 -0400</lastBuildDate>
    <atom:link href="http://blog.idempotent.ca/categories/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Use Python bytecode to solve puzzler</title>
      <link>http://blog.idempotent.ca/2015/09/03/use-python-bytecode-to-solve-puzzler/</link>
      <pubDate>Thu, 03 Sep 2015 22:16:36 -0400</pubDate>
      
      <guid>http://blog.idempotent.ca/2015/09/03/use-python-bytecode-to-solve-puzzler/</guid>
      <description>

&lt;h2 id=&#34;learning-python-internals:6bf435374bd39002427720546dfc1a00&#34;&gt;Learning Python Internals&lt;/h2&gt;

&lt;p&gt;Recently I stumbled upon &lt;a href=&#34;https://www.youtube.com/playlist?list=PLwyG5wA5gIzgTFj5KgJJ15lxq5Cv6lo_0&#34;&gt;this wonderful set of videos on Python interpreter internals&lt;/a&gt;. (Thanks to &lt;a href=&#34;http://pgbovine.net/&#34;&gt;Philip Guo&lt;/a&gt; for creating them and thanks to Michael Kennedy (@mkennedy) and his &lt;a href=&#34;http://talkpython.fm/&#34;&gt;Talk Python to me&lt;/a&gt; show that brought this on my radar)&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been using Python for about ten years but I&amp;rsquo;ve never really truly been able to understand how the interpreter works, nor was I familiar with the Python virtual machine or the bytecode. These videos may just be the extra help I needed to get me started at the internals of Python.&lt;/p&gt;

&lt;p&gt;So far, I&amp;rsquo;ve only watched 2 lectures and I&amp;rsquo;m already learning a lot. I learned where to find a list of opcodes in the source code, where the main eval loop is, and what internal states the Python virtual machine keeps.&lt;/p&gt;

&lt;p&gt;Then I thought to myself, why not use this new found power to solve some Python mysterious that have been puzzling me?&lt;/p&gt;

&lt;h2 id=&#34;the-puzzler:6bf435374bd39002427720546dfc1a00&#34;&gt;The puzzler&lt;/h2&gt;

&lt;p&gt;A few days ago, one of my former co-workers posted this puzzler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;(a, b) = a[b] = {}, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What are the values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; after the assignment? Well, it&amp;rsquo;s not obvious what the order of assignment it is going to be. Putting it in the REPL gives us this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; (a, b) = a[b] = {}, 5
&amp;gt;&amp;gt;&amp;gt; a
{5: ({...}, 5)}
&amp;gt;&amp;gt;&amp;gt; a[5]
({5: ({...}, 5)}, 5)
&amp;gt;&amp;gt;&amp;gt; a[5][0]
{5: ({...}, 5)}
&amp;gt;&amp;gt;&amp;gt; a[5][0][5]
({5: ({...}, 5)}, 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, so there appears to be a circular reference going on here. The object that &lt;code&gt;a&lt;/code&gt; refers to has an element that refers to the object that &lt;code&gt;a&lt;/code&gt; refers to and so on and so forth. Now, the question is, how did the circular reference get there?&lt;/p&gt;

&lt;p&gt;Well, all Python source code eventually get compiled down to bytecode and executed on the virtual machine. In order to understand what that line actually does, we need to look at the byte code.&lt;/p&gt;

&lt;p&gt;It turns out that Python comes with a module to disassemble source code into byte codes (assembly for the virtual machine):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python -m dis
a, b = a[5] = {}, 5
^D
  1           0 BUILD_MAP                0
              3 LOAD_CONST               0 (5)
              6 BUILD_TUPLE              2
              9 DUP_TOP
             10 UNPACK_SEQUENCE          2
             13 STORE_NAME               0 (a)
             16 STORE_NAME               1 (b)
             19 LOAD_NAME                0 (a)
             22 LOAD_CONST               0 (5)
             25 STORE_SUBSCR
             26 LOAD_CONST               1 (None)
             29 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alright, so that humble little line of code is actually 12 instructions for the Python virtual machine. Each instruction manipulates the virtual machine&amp;rsquo;s internal state in some way. CPython is a stack-based interpreter, which means certain instructions puts values on the stack and other instructions consume them from the stack.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go through the instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 BUILD_MAP                0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First off, it tells the interpreter to make a map object and put it on the value stack. After this instruction, our value stack looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+----+
| {} |
+----+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 LOAD_CONST               0 (5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This loads a constant (&lt;code&gt;5&lt;/code&gt;) on the stack.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+----+
| {} |
+----+
| 5  |
+----+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;6 BUILD_TUPLE              2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This instruction builds a &lt;code&gt;PyTuple&lt;/code&gt; object of size &lt;code&gt;2&lt;/code&gt;, which is in the argument of the opcode. It consumes the top &lt;code&gt;2&lt;/code&gt; things on the stack and make a 2-tuple using these values and put the result tuple on the value stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------+
| ({}, 5) |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;9 DUP_TOP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we have the &lt;code&gt;DUP_TOP&lt;/code&gt; instruction. It probably stands for &amp;ldquo;duplicate the top of the stack&amp;rdquo;, and reading the corresponding code in the eval loop, this seems to be what it&amp;rsquo;s doing: it gets the object from the top of the stack without popping it off and push the value on the stack, while incrementing the refcount of the object.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s worth noting that this only duplicates the tuple object. The elements inside the tuple are of type &lt;code&gt;*PyObject&lt;/code&gt;, which are pointers to the corresponding values (the dict and the integer), and are not duplicated by this instruction. Here&amp;rsquo;s the value stack after this instruction:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------+
| ({}, 5) |
+---------+
| ({}, 5) |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;10 UNPACK_SEQUENCE          2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next instruction is &lt;code&gt;UNPACK_SEQUENCE&lt;/code&gt; with argument &lt;code&gt;2&lt;/code&gt;. This will first pop the stack, so &lt;code&gt;({}, 5)&lt;/code&gt; is off the stack, and then push each element from the tuple on the stack in reverse order. After this instruction, the stack will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------+
| ({}, 5) |
+---------+
|   5     |
+---------+
|   {}    |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;13 STORE_NAME               0 (a)
16 STORE_NAME               1 (b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next two instructions deal with &amp;ldquo;names&amp;rdquo;, which are variables for the scope of the frame. &lt;code&gt;STORE_NAME a&lt;/code&gt; will pop the stack, and point &lt;code&gt;a&lt;/code&gt; to the value, and similarily for &lt;code&gt;STORE_NAME b&lt;/code&gt;. After this instruction, there will be two bindings in the frame: &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and the stack will be back to having only one element, the tuple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stack:
+---------+
| ({}, 5) |
+---------+

bindings:
a &amp;lt;- {}
b &amp;lt;- 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next two instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;19 LOAD_NAME                0 (a)
22 LOAD_CONST               0 (5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LOAD_NAME a&lt;/code&gt; will push the value that the variable is bound to on the stack, so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stack:
+---------+
| ({}, 5) |
+---------+
|    {}   |
+---------+

bindings:
a &amp;lt;- {}
b &amp;lt;- 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;LOAD_CONST 5&lt;/code&gt;, as we&amp;rsquo;ve seen before, simply pushes the constant &lt;code&gt;5&lt;/code&gt; on the stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stack:
+---------+
| ({}, 5) |
+---------+
|    {}   |
+---------+
|     5   |
+---------+

bindings:
a &amp;lt;- {}
b &amp;lt;- 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;25 STORE_SUBSCR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is where the magic happens. &lt;code&gt;STORE_SUBSCR&lt;/code&gt; is an instruction to set element on the dictionary given the index. Here&amp;rsquo;s the code that handles this opcode in the eval loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TARGET_NOARG(STORE_SUBSCR)
{
    w = TOP();
    v = SECOND();
    u = THIRD();
    STACKADJ(-3);
    /* v[w] = u */
    err = PyObject_SetItem(v, w, u);
    Py_DECREF(u);
    Py_DECREF(v);
    Py_DECREF(w);
    if (err == 0) DISPATCH();
    break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &lt;code&gt;TOP&lt;/code&gt;, &lt;code&gt;SECOND&lt;/code&gt;, &lt;code&gt;THIRD&lt;/code&gt; are macros that take values off of the value stack. Given our state of the virtual machine:
* &lt;code&gt;w = TOP()&lt;/code&gt; =&amp;gt; &lt;code&gt;w = 5&lt;/code&gt;
* &lt;code&gt;v = SECOND()&lt;/code&gt; =&amp;gt; &lt;code&gt;v = {}&lt;/code&gt;
* &lt;code&gt;w = THIRD()&lt;/code&gt; =&amp;gt; &lt;code&gt;w = ({}, 5)&lt;/code&gt;, but keep in mind, the first element in &lt;code&gt;w&lt;/code&gt; (the tuple) is actually the same object &lt;code&gt;v&lt;/code&gt; is pointing to.&lt;/p&gt;

&lt;p&gt;Thus, calling &lt;code&gt;PyObject_SetItem(v, w, u)&lt;/code&gt; sets &lt;code&gt;v[w] = u&lt;/code&gt; =&amp;gt; &lt;code&gt;v[5] = (v, 5)&lt;/code&gt;, and there a circular reference is born!&lt;/p&gt;

&lt;p&gt;From the sequence of operation, we can tell the order by which the assignments were executed:
1. &lt;code&gt;a, b = {}, 5&lt;/code&gt;
2. &lt;code&gt;a[5] = ({}, 5)&lt;/code&gt;, with &lt;code&gt;a&lt;/code&gt; refering to the dictionary&lt;/p&gt;

&lt;h2 id=&#34;conclusion:6bf435374bd39002427720546dfc1a00&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Diving into the Python implementation is the next level ninjary that may come in handy in some cases. Granted, no one is going to write production code like the one in the puzzler, but stepping through and visualizing the virtual machine is a pretty useful and fun experience that makes me appreciate more the language I use everyday.&lt;/p&gt;

&lt;p&gt;Again, thanks to Philip Guo for the videos and Michael Kennedy for the podcast. Also, checkout Professor Guo&amp;rsquo;s &lt;a href=&#34;http://www.pythontutor.com/&#34;&gt;python tutor&lt;/a&gt; for visualizing how code is run.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use Python bytecode to solve puzzler</title>
      <link>http://blog.idempotent.ca/starred/2015-09-03-use-python-bytecode-to-solve-puzzler/</link>
      <pubDate>Thu, 03 Sep 2015 22:16:36 -0400</pubDate>
      
      <guid>http://blog.idempotent.ca/starred/2015-09-03-use-python-bytecode-to-solve-puzzler/</guid>
      <description>

&lt;h2 id=&#34;learning-python-internals:6bf435374bd39002427720546dfc1a00&#34;&gt;Learning Python Internals&lt;/h2&gt;

&lt;p&gt;Recently I stumbled upon &lt;a href=&#34;https://www.youtube.com/playlist?list=PLwyG5wA5gIzgTFj5KgJJ15lxq5Cv6lo_0&#34;&gt;this wonderful set of videos on Python interpreter internals&lt;/a&gt;. (Thanks to &lt;a href=&#34;http://pgbovine.net/&#34;&gt;Philip Guo&lt;/a&gt; for creating them and thanks to Michael Kennedy (@mkennedy) and his &lt;a href=&#34;http://talkpython.fm/&#34;&gt;Talk Python to me&lt;/a&gt; show that brought this on my radar)&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been using Python for about ten years but I&amp;rsquo;ve never really truly been able to understand how the interpreter works, nor was I familiar with the Python virtual machine or the bytecode. These videos may just be the extra help I needed to get me started at the internals of Python.&lt;/p&gt;

&lt;p&gt;So far, I&amp;rsquo;ve only watched 2 lectures and I&amp;rsquo;m already learning a lot. I learned where to find a list of opcodes in the source code, where the main eval loop is, and what internal states the Python virtual machine keeps.&lt;/p&gt;

&lt;p&gt;Then I thought to myself, why not use this new found power to solve some Python mysterious that have been puzzling me?&lt;/p&gt;

&lt;h2 id=&#34;the-puzzler:6bf435374bd39002427720546dfc1a00&#34;&gt;The puzzler&lt;/h2&gt;

&lt;p&gt;A few days ago, one of my former co-workers posted this puzzler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;(a, b) = a[b] = {}, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What are the values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; after the assignment? Well, it&amp;rsquo;s not obvious what the order of assignment it is going to be. Putting it in the REPL gives us this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; (a, b) = a[b] = {}, 5
&amp;gt;&amp;gt;&amp;gt; a
{5: ({...}, 5)}
&amp;gt;&amp;gt;&amp;gt; a[5]
({5: ({...}, 5)}, 5)
&amp;gt;&amp;gt;&amp;gt; a[5][0]
{5: ({...}, 5)}
&amp;gt;&amp;gt;&amp;gt; a[5][0][5]
({5: ({...}, 5)}, 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, so there appears to be a circular reference going on here. The object that &lt;code&gt;a&lt;/code&gt; refers to has an element that refers to the object that &lt;code&gt;a&lt;/code&gt; refers to and so on and so forth. Now, the question is, how did the circular reference get there?&lt;/p&gt;

&lt;p&gt;Well, all Python source code eventually get compiled down to bytecode and executed on the virtual machine. In order to understand what that line actually does, we need to look at the byte code.&lt;/p&gt;

&lt;p&gt;It turns out that Python comes with a module to disassemble source code into byte codes (assembly for the virtual machine):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python -m dis
a, b = a[5] = {}, 5
^D
  1           0 BUILD_MAP                0
              3 LOAD_CONST               0 (5)
              6 BUILD_TUPLE              2
              9 DUP_TOP
             10 UNPACK_SEQUENCE          2
             13 STORE_NAME               0 (a)
             16 STORE_NAME               1 (b)
             19 LOAD_NAME                0 (a)
             22 LOAD_CONST               0 (5)
             25 STORE_SUBSCR
             26 LOAD_CONST               1 (None)
             29 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alright, so that humble little line of code is actually 12 instructions for the Python virtual machine. Each instruction manipulates the virtual machine&amp;rsquo;s internal state in some way. CPython is a stack-based interpreter, which means certain instructions puts values on the stack and other instructions consume them from the stack.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go through the instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 BUILD_MAP                0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First off, it tells the interpreter to make a map object and put it on the value stack. After this instruction, our value stack looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+----+
| {} |
+----+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 LOAD_CONST               0 (5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This loads a constant (&lt;code&gt;5&lt;/code&gt;) on the stack.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+----+
| {} |
+----+
| 5  |
+----+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;6 BUILD_TUPLE              2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This instruction builds a &lt;code&gt;PyTuple&lt;/code&gt; object of size &lt;code&gt;2&lt;/code&gt;, which is in the argument of the opcode. It consumes the top &lt;code&gt;2&lt;/code&gt; things on the stack and make a 2-tuple using these values and put the result tuple on the value stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------+
| ({}, 5) |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;9 DUP_TOP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we have the &lt;code&gt;DUP_TOP&lt;/code&gt; instruction. It probably stands for &amp;ldquo;duplicate the top of the stack&amp;rdquo;, and reading the corresponding code in the eval loop, this seems to be what it&amp;rsquo;s doing: it gets the object from the top of the stack without popping it off and push the value on the stack, while incrementing the refcount of the object.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s worth noting that this only duplicates the tuple object. The elements inside the tuple are of type &lt;code&gt;*PyObject&lt;/code&gt;, which are pointers to the corresponding values (the dict and the integer), and are not duplicated by this instruction. Here&amp;rsquo;s the value stack after this instruction:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------+
| ({}, 5) |
+---------+
| ({}, 5) |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;10 UNPACK_SEQUENCE          2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next instruction is &lt;code&gt;UNPACK_SEQUENCE&lt;/code&gt; with argument &lt;code&gt;2&lt;/code&gt;. This will first pop the stack, so &lt;code&gt;({}, 5)&lt;/code&gt; is off the stack, and then push each element from the tuple on the stack in reverse order. After this instruction, the stack will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------+
| ({}, 5) |
+---------+
|   5     |
+---------+
|   {}    |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;13 STORE_NAME               0 (a)
16 STORE_NAME               1 (b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next two instructions deal with &amp;ldquo;names&amp;rdquo;, which are variables for the scope of the frame. &lt;code&gt;STORE_NAME a&lt;/code&gt; will pop the stack, and point &lt;code&gt;a&lt;/code&gt; to the value, and similarily for &lt;code&gt;STORE_NAME b&lt;/code&gt;. After this instruction, there will be two bindings in the frame: &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and the stack will be back to having only one element, the tuple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stack:
+---------+
| ({}, 5) |
+---------+

bindings:
a &amp;lt;- {}
b &amp;lt;- 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next two instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;19 LOAD_NAME                0 (a)
22 LOAD_CONST               0 (5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LOAD_NAME a&lt;/code&gt; will push the value that the variable is bound to on the stack, so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stack:
+---------+
| ({}, 5) |
+---------+
|    {}   |
+---------+

bindings:
a &amp;lt;- {}
b &amp;lt;- 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;LOAD_CONST 5&lt;/code&gt;, as we&amp;rsquo;ve seen before, simply pushes the constant &lt;code&gt;5&lt;/code&gt; on the stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stack:
+---------+
| ({}, 5) |
+---------+
|    {}   |
+---------+
|     5   |
+---------+

bindings:
a &amp;lt;- {}
b &amp;lt;- 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;25 STORE_SUBSCR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is where the magic happens. &lt;code&gt;STORE_SUBSCR&lt;/code&gt; is an instruction to set element on the dictionary given the index. Here&amp;rsquo;s the code that handles this opcode in the eval loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TARGET_NOARG(STORE_SUBSCR)
{
    w = TOP();
    v = SECOND();
    u = THIRD();
    STACKADJ(-3);
    /* v[w] = u */
    err = PyObject_SetItem(v, w, u);
    Py_DECREF(u);
    Py_DECREF(v);
    Py_DECREF(w);
    if (err == 0) DISPATCH();
    break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &lt;code&gt;TOP&lt;/code&gt;, &lt;code&gt;SECOND&lt;/code&gt;, &lt;code&gt;THIRD&lt;/code&gt; are macros that take values off of the value stack. Given our state of the virtual machine:
* &lt;code&gt;w = TOP()&lt;/code&gt; =&amp;gt; &lt;code&gt;w = 5&lt;/code&gt;
* &lt;code&gt;v = SECOND()&lt;/code&gt; =&amp;gt; &lt;code&gt;v = {}&lt;/code&gt;
* &lt;code&gt;w = THIRD()&lt;/code&gt; =&amp;gt; &lt;code&gt;w = ({}, 5)&lt;/code&gt;, but keep in mind, the first element in &lt;code&gt;w&lt;/code&gt; (the tuple) is actually the same object &lt;code&gt;v&lt;/code&gt; is pointing to.&lt;/p&gt;

&lt;p&gt;Thus, calling &lt;code&gt;PyObject_SetItem(v, w, u)&lt;/code&gt; sets &lt;code&gt;v[w] = u&lt;/code&gt; =&amp;gt; &lt;code&gt;v[5] = (v, 5)&lt;/code&gt;, and there a circular reference is born!&lt;/p&gt;

&lt;p&gt;From the sequence of operation, we can tell the order by which the assignments were executed:
1. &lt;code&gt;a, b = {}, 5&lt;/code&gt;
2. &lt;code&gt;a[5] = ({}, 5)&lt;/code&gt;, with &lt;code&gt;a&lt;/code&gt; refering to the dictionary&lt;/p&gt;

&lt;h2 id=&#34;conclusion:6bf435374bd39002427720546dfc1a00&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Diving into the Python implementation is the next level ninjary that may come in handy in some cases. Granted, no one is going to write production code like the one in the puzzler, but stepping through and visualizing the virtual machine is a pretty useful and fun experience that makes me appreciate more the language I use everyday.&lt;/p&gt;

&lt;p&gt;Again, thanks to Philip Guo for the videos and Michael Kennedy for the podcast. Also, checkout Professor Guo&amp;rsquo;s &lt;a href=&#34;http://www.pythontutor.com/&#34;&gt;python tutor&lt;/a&gt; for visualizing how code is run.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use Python&#39;s sys.settrace() for fun and for profit</title>
      <link>http://blog.idempotent.ca/2012/04/17/use-pythons-sys.settrace-for-fun-and-for-profit/</link>
      <pubDate>Tue, 17 Apr 2012 16:58:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2012/04/17/use-pythons-sys.settrace-for-fun-and-for-profit/</guid>
      <description>

&lt;h2 id=&#34;the-itch-to-scratch:c0963e613fb36e35763da3ad0b838456&#34;&gt;The itch to scratch&lt;/h2&gt;

&lt;p&gt;Everyone in the software industry knows Kent Beck, the pioneers of extreme programming and test-driven development and the co-author of JUnit. One of his lesser known project was &lt;a href=&#34;http://junitmax.com&#34;&gt;JUnitMax&lt;/a&gt;, which aims to reduce the time developers have to wait while tests are running. One of the ideas behind that is that when code changes, only the test cases that exercise the code need to be run, instead of running the entire suite. The idea makes a lot of sense to me, but at the time, I (and the development shop I was in) wasn&amp;rsquo;t practising enough TDD, so unit test time wasn&amp;rsquo;t a big problem for me back then.&lt;/p&gt;

&lt;p&gt;Fast-forward a few years, now as the project in my current company gets bigger, the time it takes to run tests is slowly becoming an impeding factor of my productivity. I remembered JUnitMax and say to myself, wouldn&amp;rsquo;t it be neat if something like JUnitMax were available? As the name suggests, JUnitMax is for Java while my project is in Python. Java, being a statically-typed language, has the blessings of statical analysis, which means a tool like JUnitMax can figure out which test cases cover which lines of code simply by type analysis. Python, however, being a dynamic language, doesn&amp;rsquo;t have this ability.&lt;/p&gt;

&lt;p&gt;A few days ago, while I was running unit tests with coverage, it dawned on me that if the coverage tool knows which lines of the source code is covered by unit tests, couldn&amp;rsquo;t the same technique be used to figure out which lines are covered by which test cases?&lt;/p&gt;

&lt;p&gt;So, I started looking into &lt;a href=&#34;http://nedbatchelder.com/code/coverage/&#34;&gt;coveragepy&lt;/a&gt;&amp;rsquo;s source code, and watching its author &lt;a href=&#34;http://nedbatchelder.com/blog/&#34;&gt;Ned Batchelder&lt;/a&gt;&amp;rsquo;s excellent PyCon2011 &lt;a href=&#34;http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2011-python-aware-python-4896752&#34;&gt;video&lt;/a&gt; on &lt;code&gt;sys.settrace&lt;/code&gt;. I wanted to build a proof-of-concept tool that integrates with the de-facto Python unit-test tool &lt;a href=&#34;https://github.com/nose-devs/nose&#34;&gt;nose&lt;/a&gt;, that, when run, gathers the information about which lines in the files in the source folder are covered by which test cases, and hence &lt;a href=&#34;https://github.com/kevinjqiu/nostrils&#34;&gt;nostrils&lt;/a&gt; is born.&lt;/p&gt;

&lt;h2 id=&#34;here-comes-sys-settrace:c0963e613fb36e35763da3ad0b838456&#34;&gt;Here comes &lt;code&gt;sys.settrace()&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Python&amp;rsquo;s motto is &amp;ldquo;batteries included&amp;rdquo;. This is manifested in many Python&amp;rsquo;s stanndard library modules, such as ast (source code parsing) and dis (bytecode disassembly). One of which is the ability to make the Python interpreter call an external function whenever a line of code is being executed. You can do a lot of fun stuff with it, for example, Coverage.py uses this to build code coverage data; pdb uses it to insert breakpoints into a running application and change the way a Python program is executed.&lt;/p&gt;

&lt;h2 id=&#34;how-can-it-be-used:c0963e613fb36e35763da3ad0b838456&#34;&gt;How can it be used?&lt;/h2&gt;

&lt;p&gt;For &lt;em&gt;nostrils&lt;/em&gt;, we need to write a nose plugin that installs the trace function when a test is encountered. The trace function records the line numbers and the current test case name. After all tests are run, we have our map.&lt;/p&gt;

&lt;h2 id=&#34;a-simple-use-case:c0963e613fb36e35763da3ad0b838456&#34;&gt;A simple use case&lt;/h2&gt;

&lt;p&gt;To start, we need a simple use case:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# worker.py
# this is the code-under-test
def add(x, y):
    z = x + y
    return z

def subtract(x, y):
    z = x - y
    return z
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# test_worker.py
# test cases

import worker

def test_add():
    assert 1 == worker.add(1, 0)

def test_add___negative():
    assert 0 == worker.add(-1, 1)

def test_subtract():
    assert 0 == worker.subtract(0, 0)

class TestFoo(object):

    def test_add(self):
        assert 5 == worker.add(5, 0)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we have 4 tests and 2 methods-under-test. Our goal is that when running &lt;code&gt;nosetests --with-nostrils&lt;/code&gt; (&lt;code&gt;--with-nostrils&lt;/code&gt; is the switch to turn on the nostrils plugin), we get the following mappings:&lt;/p&gt;

&lt;p&gt;```python worker.py
def add(x, y):
  z = x + y # test_add, test_add_negative, TestFoo.test_add
  return z  # test_add, test_add_negative, TestFoo.test_add&lt;/p&gt;

&lt;p&gt;def subtract(x, y):
  z = x - y # test_subtract
  return z  # test_subtract&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
## Nose plugin

I won&#39;t go into the details about how to create a plugin for nose. You can read it [here](http://readthedocs.org/docs/nose/en/latest/plugins/writing.html, and you can take a look at my sample setup [here](https://raw.github.com/kevinjqiu/nostrils/master/setup.py). In a nutshell, every plugin has a name, and when nose is supplied with --with-*plugin_name*, your plugin is activated. Nose provides a test lifecycle &amp;quot;hooks&amp;quot; that plugins can implement. For example, `startTest` is called when a test case is discovered and adapted into a nose [TestCase](http://readthedocs.org/docs/nose/en/latest/api/test_cases.html). `addSuccess` is called when a test case succeeded. `finalize` is called when all tests are finished.

Here&#39;s how my plugin looks like:

```python
class Nostrils(Plugin):
    name = &#39;nostrils&#39;

    def addError(self, test, err, *args):
        self._restore_tracefn()

    def addFailure(self, test, err, *args):
        self._restore_tracefn()

    def addSkip(self, test, err):
        self._restore_tracefn()

    def addSuccess(self, test, err):
        self._restore_tracefn()

    def startTest(self, test):
        self._current_test = test
        self._install_tracefn()

    def finalize(self, result):
        self._print()

    def _install_tracefn(self):
        self._orig_tracefn = sys.gettrace()
        sys.settrace(self._trace) # See below

    def _restore_tracefn(self):
        sys.settrace(self._orig_tracefn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The idea is that we install the trace function when test starts, and restore the trace function back to what it was. We also keeps track of what&amp;rsquo;s the current test in &lt;code&gt;self._current_test&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;trace-function:c0963e613fb36e35763da3ad0b838456&#34;&gt;Trace function&lt;/h2&gt;

&lt;p&gt;Now let&amp;rsquo;s have a look at the trace function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Nostrils(Plugin):
  # ...
  def _trace(self, frame, event, arg):
    if event == &#39;line&#39;:
      self._trace_down(frame)
    return self._trace

  def _trace_down(self, frame):
    while frame is not None:
      if frame.f_code == test.__call__.func_code:
        break

      self._collect(frame)
      frame = frame.f_back
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A trace function should take 3 parameters:
* frame: the current &lt;a href=&#34;http://docs.python.org/reference/datamodel.html#types&#34;&gt;frame&lt;/a&gt; object
* event: what type of event that triggered the trace function? See &lt;a href=&#34;http://docs.python.org/library/sys.html#sys.settrace&#34;&gt;here&lt;/a&gt;
* &lt;code&gt;*args&lt;/code&gt;: any additional arguments&lt;/p&gt;

&lt;p&gt;Here, I&amp;rsquo;m only interested in the &lt;code&gt;line&lt;/code&gt; event, which is triggered when a new line of code is being executed. When this happens, we invoke &lt;code&gt;_trace_down&lt;/code&gt;, which walks the frame stack by recursing on &lt;code&gt;frame.f_back&lt;/code&gt;. When it&amp;rsquo;s &lt;code&gt;None&lt;/code&gt;, we&amp;rsquo;re at the bottom of the stack. Because we&amp;rsquo;re tracing the execution of tests, we can probably stop traversing when the code object of the frame is the entry point of the test case (&lt;code&gt;if frame.f_code == test.__call__.func_code&lt;/code&gt;). This way, we save ourselves some unnecessary traversals.&lt;/p&gt;

&lt;h2 id=&#34;data-collection:c0963e613fb36e35763da3ad0b838456&#34;&gt;Data Collection&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;s are few things we need to collect: filename, line number of the code being executed and the test case name that covers the code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Nostrils(Plugin):
  def __init__(self):
    super(Nostrils, self).__init__()
    self._data = defaultdict(
      lambda : defaultdict(
        lambda : set([])
      )
    )

  def _collect(self, frame):
    filename, lineno = frame.f_code.co_filename, frame.f_lineno
    self._data[filename][lineno].add(&amp;quot;%s:%s.%s&amp;quot; % self._current_test.address())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The data structure we use here is a dictionary of dictionary. At the top level, the keys are filenames, and the values are dictionaries of with keys the line numbers and the values the set of test case names. The data structure looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &#39;foo.py&#39;:{
      1 : set([&#39;test_foo.py:test_foo_case1&#39;, &#39;test_foo.py:test_foo_case2&#39;]),
      2 : set([&#39;test_foo.py:test_foo_case1&#39;, &#39;test_foo.py:test_foo_case2&#39;]),
      3 : set([&#39;test_foo.py:test_foo_case2&#39;])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There we have it! We have a prototype of what could become a PyUnitMax ;)&lt;/p&gt;

&lt;h2 id=&#34;potential-problems:c0963e613fb36e35763da3ad0b838456&#34;&gt;Potential Problems&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Scale: Now I&amp;rsquo;m only running nostrils on trivial code base. Profiling and optimization is needed if nostrils were to be used in real-world cases.&lt;/li&gt;&lt;/li&gt;
&lt;li&gt;Multi-threading: No consideration was given to multi-threading at this stage.&lt;/li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;collaborators-welcome:c0963e613fb36e35763da3ad0b838456&#34;&gt;Collaborators welcome!&lt;/h2&gt;

&lt;p&gt;I have since refactored the code, revised the data structure and published it on &lt;a href=&#34;https://github.com/kevinjqiu/nostrils&#34;&gt;github&lt;/a&gt;. Please provide me with feedbacks and suggestions.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Realtime notification delivery using rabbitmq</title>
      <link>http://blog.idempotent.ca/2012/04/07/realtime-notification-delivery-using-rabbitmq/</link>
      <pubDate>Sat, 07 Apr 2012 16:50:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2012/04/07/realtime-notification-delivery-using-rabbitmq/</guid>
      <description>

&lt;p&gt;Our company has &amp;ldquo;hack-off&amp;rdquo; days once a while, where we developers get to choose whatever we would like to work on and present it to the entire company by the end of the day. I have been hearing this &lt;a href=&#34;http://en.wikipedia.org/wiki/WebSocket&#34;&gt;websocket&lt;/a&gt; buzz for a while now and would like to build something interesting with it.&lt;/p&gt;

&lt;h2 id=&#34;websocket:3652469de01842bf96882033c0b91b72&#34;&gt;WebSocket&lt;/h2&gt;

&lt;p&gt;Websocket is a persistent bi-directional connection between the browser and the server. With websocket, web browser can post message to the server, but what&amp;rsquo;s more interesting is that the server is able to push messages to the client (browser). This breaks away from the traditional web application request/response model. Traditionally, the client makes the request and waits for the server to give an answer. AJAX is revolutionary, but essentially, it&amp;rsquo;s still the same model: the client asks the server whether there&amp;rsquo;s anything interesting, but not the other way around. With websocket, the server suddenly becomes more involved and able to deliver more engaged user experience.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.freshbooks.com/&#34;&gt;Our company&lt;/a&gt; provides web application for online invoicing. The web application allows users to create clients, create invoices, send them to clients, and so on. Each one of these are &amp;ldquo;events&amp;rdquo; which gets sent to &lt;a href=&#34;http://www.rabbitmq.com/&#34;&gt;RabbitMQ&lt;/a&gt;. We then have a plethora of RabbitMQ consumers that read messages off the queue and do interesting stuff with them.&lt;/p&gt;

&lt;h2 id=&#34;proof-of-concept:3652469de01842bf96882033c0b91b72&#34;&gt;Proof of concept&lt;/h2&gt;

&lt;p&gt;For this hack-off, my goal is to write a RabbitMQ consumer that reads the messages off the message queue, and deliver (notify) them to the front-end using websocket.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://reminiscential.files.wordpress.com/2012/04/websocket-1.png&#34;&gt;&lt;img src=&#34;http://reminiscential.files.wordpress.com/2012/04/websocket-1.png?w=300&#34; alt=&#34;&#34; title=&#34;architecture&#34; width=&#34;300&#34; height=&#34;181&#34; class=&#34;aligncenter size-medium wp-image-292&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve heard good things about &lt;a href=&#34;http://www.tornadoweb.org&#34;&gt;Tornado&lt;/a&gt;. Having read their docs on &lt;a href=&#34;http://www.tornadoweb.org/documentation/websocket.html&#34;&gt;websocket request handler&lt;/a&gt;, I felt it&amp;rsquo;s straightforward enough for me, so I chose Tornado as my backend.&lt;/p&gt;

&lt;h2 id=&#34;pika:3652469de01842bf96882033c0b91b72&#34;&gt;Pika&lt;/h2&gt;

&lt;p&gt;One problem arises, though: The tornado server will run as a regular server, waiting for incoming websocket connections. The RabbitMQ consumer also needs to be in the same process event loop, waiting for incoming messages from the message queue. I looked into a few solutions such as &lt;a href=&#34;http://pypi.python.org/pypi/sparkplug/&#34;&gt;sparkplug&lt;/a&gt; and &lt;a href=&#34;http://pypi.python.org/pypi/stormed-amqp/0.1&#34;&gt;stormed-amqp&lt;/a&gt;, neither seem to be a good hit here. Finally, I stumbled on &lt;a href=&#34;https://github.com/pika/pika&#34;&gt;Pika&lt;/a&gt;. It comes with a Tornado event loop adapter, which allows rabbitmq consumer and websocket handlers to run inside the same event loop. Perfect.&lt;/p&gt;

&lt;p&gt;The entry point looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;application = tornado.web.Application([
    (r&#39;/ws&#39;, handlers.MyWebSocketHandler),
])

def main():
    pika.log.setup(color=True)

    io_loop = tornado.ioloop.IOLoop.instance()

    # PikaClient is our rabbitmq consumer
    pc = client.PikaClient(io_loop)
    application.pc = pc
    application.pc.connect()

    application.listen(8888)
    io_loop.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyWebSocketHandler(tornado.websocket.WebSocketHandler):

    def open(self, *args, **kwargs):
        pika.log.info(&amp;quot;WebSocket opened&amp;quot;)

    def on_close(self):
        pika.log.info(&amp;quot;WebSocket closed&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was straightforward. However, I&amp;rsquo;m faced with the problem of how to make the amqp consumer notify websocket handlers when we receive a message from the message queue. We cannot get the handler instances from the tornado application object. Note, each websocket connection has a corresponding &lt;code&gt;MyWebSocketHandler&lt;/code&gt; instance. The instances are not available from the application object. Maybe there&amp;rsquo;s a way to get them by other means, but I&amp;rsquo;m not familiar with the tornado API enough to know that.&lt;/p&gt;

&lt;p&gt;However, from the handler, we do get the &lt;code&gt;application&lt;/code&gt; object, and because we attached pika_client (our amqp consumer) to the application, we have access to it inside our socket handler. Hey, how about registering the handler with the client when the websocket is connected, and let the client &amp;ldquo;notify&amp;rdquo; the handler when events are received? Hey, isn&amp;rsquo;t that the &lt;a href=&#34;http://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;observer pattern&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyWebSocketHandler(websocket.WebSocketHandler):

    def open(self, *args, **kwargs):
        self.application.pc.add_event_listener(self)
        pika.log.info(&amp;quot;WebSocket opened&amp;quot;)

    def on_close(self):
        pika.log.info(&amp;quot;WebSocket closed&amp;quot;)
        self.application.pc.remove_event_listener(self)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, our &lt;code&gt;PikaClient&lt;/code&gt; object need to support &lt;code&gt;add_event_listener()&lt;/code&gt; and &lt;code&gt;remove_event_listener()&lt;/code&gt; methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class PikaClient(object):

    def __init__(self, io_loop):
        pika.log.info(&#39;PikaClient: __init__&#39;)
        self.io_loop = io_loop

        self.connected = False
        self.connecting = False
        self.connection = None
        self.channel = None

        self.event_listeners = set([])

    def connect(self):
        if self.connecting:
            pika.log.info(&#39;PikaClient: Already connecting to RabbitMQ&#39;)
            return

        pika.log.info(&#39;PikaClient: Connecting to RabbitMQ&#39;)
        self.connecting = True

        cred = pika.PlainCredentials(&#39;guest&#39;, &#39;guest&#39;)
        param = pika.ConnectionParameters(
            host=&#39;localhost&#39;,
            port=5672,
            virtual_host=&#39;/&#39;,
            credentials=cred
        )

        self.connection = TornadoConnection(param,
            on_open_callback=self.on_connected)
        self.connection.add_on_close_callback(self.on_closed)

    def on_connected(self, connection):
        pika.log.info(&#39;PikaClient: connected to RabbitMQ&#39;)
        self.connected = True
        self.connection = connection
        self.connection.channel(self.on_channel_open)

    def on_channel_open(self, channel):
        pika.log.info(&#39;PikaClient: Channel open, Declaring exchange&#39;)
        self.channel = channel
        # declare exchanges, which in turn, declare
        # queues, and bind exchange to queues

    def on_closed(self, connection):
        pika.log.info(&#39;PikaClient: rabbit connection closed&#39;)
        self.io_loop.stop()

    def on_message(self, channel, method, header, body):
        pika.log.info(&#39;PikaClient: message received: %s&#39; % body)
        self.notify_listeners(event_factory(body))

    def notify_listeners(self, event_obj):
        # here we assume the message the sourcing app
        # post to the message queue is in JSON format
        event_json = json.dumps(event_ostener in self.event_listeners:
            listener.write_message(event_json)
            pika.log.info(&#39;PikaClient: notified %s&#39; % repr(listener))

    def add_event_listener(self, listener):
        self.event_listeners.add(listener)
        pika.log.info(&#39;PikaClient: listener %s added&#39; % repr(listener))

    def remove_event_listener(self, listener):
        try:
            self.event_listeners.remove(listener)
            pika.log.info(&#39;PikaClient: listener %s removed&#39; % repr(listener))
        except KeyError:
            pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I left out the queue setup code here for brevity. &lt;code&gt;on_message&lt;/code&gt; callback is called when the consumer gets a message from the queue. The client, in turn, notifies all registered websocket handlers. Obviously, in real applications, you may want to do some kind of credentials and filtering, so the right message get to the right receiver. Then we simply call &lt;code&gt;handler.write_message()&lt;/code&gt;, so the message gets relayed to the front-end&amp;rsquo;s websocket.onmessage callback.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s some front-end code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function($){
    $(document).ready(function() {
        var ws = new WebSocket(&#39;ws://localhost:8888/ws&#39;);
        ws.onmessage = function(evt){
            alert(evt.data);
        }
    });
})(jQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, we simply echo the message back. For the hackoff, I did parse the data, render a slightly more detailed notification message, and display the notification using jquery-toaster.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:3652469de01842bf96882033c0b91b72&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is my first stab at websocket and the tornado web framework. I&amp;rsquo;m not an expert on either subject, so chances are there are better ways to achieve the same result.&lt;/p&gt;

&lt;p&gt;I think websocket is a very interesting technology. It opens a wide range of possibilities for more interactive and engaging web applications. Our web application is of traditional architecture: server renders most of the page, and every request involves page loads. Having a websocket may not be very beneficial as the application doesn&amp;rsquo;t have that much of user interaction. My hackoff is more of a proof of concept. However, if the application is a one-page web app (no full page reloads), the websocket model works very well.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use Python decorator to curry functions</title>
      <link>http://blog.idempotent.ca/2010/10/22/use-python-decorator-to-curry-functions/</link>
      <pubDate>Fri, 22 Oct 2010 20:06:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2010/10/22/use-python-decorator-to-curry-functions/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s been a while since the last time I wrote about Python. This morning, I was listening to a podcast on my way to work. They were discussing functional programming and dynamic languages&amp;hellip;I learned Python before I went into Computer Science, and then I learned about functional programming and through learning of Scala and Clojure, my functional programming concepts have been enriched. As I was listening, it suddenly appeared to me that there isn&amp;rsquo;t a way in Python to &lt;a href=&#34;http://en.wikipedia.org/wiki/Currying&#34;&gt;curry&lt;/a&gt; a function. Not that it&amp;rsquo;s critical to everyday development, but wouldn&amp;rsquo;t it be neat if I can curry a function in Python?&lt;/p&gt;

&lt;p&gt;Then the hosts of the podcast discussed how dynamic languages are so flexible that you can pretty much do anything to it. &amp;ldquo;You can take a function as parameter, return a function from a function, and so on.&amp;rdquo; Hey, isn&amp;rsquo;t that what Python&amp;rsquo;s &lt;a href=&#34;http://www.artima.com/weblogs/viewpost.jsp?thread=240808&#34;&gt;decorator&lt;/a&gt; can do? I learned decorators before, but I haven&amp;rsquo;t used it beyond the scope of creating properties and certainly haven&amp;rsquo;t written any decorators. I thought this would be a good exercise for learning decorators.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simple example of what function currying: suppose you have a method&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add(x,y):
  return x+y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then calling &lt;code&gt;add(1,2)&lt;/code&gt; should be the same as &lt;code&gt;add(1)(2)&lt;/code&gt;. &lt;code&gt;add(1)&lt;/code&gt; is what they call a partially applied function. It&amp;rsquo;s a function that takes one parameter.&lt;/p&gt;

&lt;p&gt;Our goal here is to write a decorator &amp;ldquo;curried&amp;rdquo; that takes a function with n parameters and transform it in a way that can be applied n times and get the final result.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start with unit tests first:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import unittest

class CurryTest(unittest.TestCase):

    def test_with_no_args(self):
        @curried
        def do_nothing():
            return &amp;quot;&amp;quot;
        self.assertEquals(&amp;quot;&amp;quot;, do_nothing())

    def test_with_int_args(self):
        @curried
        def add_int(x,y):
            return x+y
        self.assertEquals(3, add_int(1)(2))
    def test_with_str_args(self):
        @curried
        def add_str(x,y):
            return &amp;quot;%s%s&amp;quot;%(x,y)
        self.assertEquals(&amp;quot;ab&amp;quot;, add_str(&amp;quot;a&amp;quot;)(&amp;quot;b&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we make sure that a currying on a function takes no parameter is valid but should be a pass through, and also the &amp;ldquo;curried&amp;rdquo; decorator can be applied to any function with arguments (excluding positional arguments and keyword arguments)&lt;/p&gt;

&lt;p&gt;A decorator is simply a function that takes a function as parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def curried(fn):
  pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;@curried&lt;/code&gt; is simply a syntactic sugar for:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fn(...): ...
fn=curried(fn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, now we can write &lt;code&gt;curried&lt;/code&gt; decorator.
To make the test for function with no argument pass, in &lt;code&gt;curried()&lt;/code&gt; function, we can test to see if fn has arguments. Python&amp;rsquo;s standard library provides &lt;code&gt;inspect.getargspec&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def curried(fn):
  argspec = inspect.getargspec(fn)
  if len(argspec.args)==0:
    return fn
  else:
    # later
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the first test passes.&lt;/p&gt;

&lt;p&gt;For the other two cases, here&amp;rsquo;s the strategy. In Python, when a class defines &lt;code&gt;__call__&lt;/code&gt; method, the instance of that class is said to be &amp;ldquo;callable&amp;rdquo;. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class A(object):
  def __call__(self, arg):
    return arg

f=A()
f(&amp;quot;echo&amp;quot;)  # this gives you &amp;quot;echo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is very similar to Scala&amp;rsquo;s &lt;code&gt;apply()&lt;/code&gt; function. Now that we have this in our inventory, we can define a &lt;code&gt;PartialFunction&lt;/code&gt; class, take all the required parameters of the original function, and allow them to be applied one at a time. So the &lt;code&gt;__call__&lt;/code&gt; method of PartialFunc will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __call__(self, value):
  # Xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If all the required parameters are passed in, &lt;code&gt;PartialFunc&lt;/code&gt; should evaluate the original function with the complete argument list. Otherwise, &lt;code&gt;PartialFunc&lt;/code&gt; stores the parameter in an instance variable, and returns itself.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the complete code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class PartialFunc(object):
    def __init__(self, fn, argspec):
        self.fn = fn
        self.argspec = argspec
        self.args = []

    def __call__(self, value):
        self.args.append(value)
        if len(self.args) == len(self.argspec.args):
            arglist = &amp;quot;,&amp;quot;.join([&amp;quot;self.args[%d]&amp;quot;%i for i in range(0, len(self.args))])
            return eval(&amp;quot;self.fn(&amp;quot; + arglist + &amp;quot;)&amp;quot;)
        else:
            return self
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the curried decorator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def curried(fn):
    argspec = inspect.getargspec(fn)
    if len(argspec.args) == 0:
        return fn
    else:
        return PartialFunc(fn, argspec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s pretty straightforward. When the parameters are complete, I construct a python statement that calls the original function with the complete argument list, and then pass the statement into an eval statement. I know evals are evil, but I can&amp;rsquo;t find a way in Python to dynamically change the signature of the original method and make it accept a variable length argument (varargs).&lt;/p&gt;

&lt;p&gt;So this is it. It&amp;rsquo;s quite simple. Python methods can have varargs and keyword args, the situation gets a little more complicated. The thing is, both varargs and keyword args are not mandatory, so it&amp;rsquo;s hard for the curried function to know whether the argument list has been completed&amp;hellip;Also, if you take default values into account, it could get even more complicated.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Enable Auto-complete in a PDB session</title>
      <link>http://blog.idempotent.ca/2009/06/12/enable-auto-complete-in-a-pdb-session/</link>
      <pubDate>Fri, 12 Jun 2009 09:25:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2009/06/12/enable-auto-complete-in-a-pdb-session/</guid>
      <description>&lt;p&gt;EDIT: 2012-06-19 There are so many other much better options now that renders recipe obsolete. See &lt;a href=&#34;https://bitbucket.org/antocuni/pdb/src&#34;&gt;pdb++&lt;/a&gt; or &lt;a href=&#34;https://github.com/gotcha/ipdb&#34;&gt;ipdb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pretty simple actually…Just put the following code in &lt;code&gt;~/.pdbrc&lt;/code&gt; and then you can use the Tab key during a PDB session to see the available attributes of the current context.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import rlcompleter
pdb.Pdb.complete=rlcompleter.Completer(locals()).complete
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Hexspeak and Generator</title>
      <link>http://blog.idempotent.ca/2008/09/03/hexspeak-and-generator/</link>
      <pubDate>Wed, 03 Sep 2008 00:03:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2008/09/03/hexspeak-and-generator/</guid>
      <description>&lt;p&gt;EDIT: 2011-04-21 While browsing my old blog posts, I found the code here can be greatly improved. Here it is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def words():
    with open(&#39;/usr/share/dict/words&#39;, &#39;r&#39;) as f:
        return (x.strip().upper() for x in f.readlines())

MAPPING = {&#39;A&#39;:&#39;A&#39;, &#39;B&#39;:&#39;B&#39;, &#39;C&#39;:&#39;C&#39;, &#39;D&#39;:&#39;D&#39;,
           &#39;E&#39;:&#39;E&#39;, &#39;F&#39;:&#39;F&#39;, &#39;O&#39;:&#39;0&#39;, &#39;S&#39;:&#39;5&#39;, &#39;I&#39;:&#39;1&#39;}

def main():
    is_hexword = lambda word: all(ch in MAPPING for ch in word)
    for word in filter(is_hexword, words()):
        print word, &amp;quot;\t&amp;quot;, &#39;&#39;.join(MAPPING.get(ch, ch) for ch in word)

if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, it’s a relatively slow day at work, and I’ve been “stumbling upon” on Wikipedia when I found this:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Hexspeak&#34;&gt;http://en.wikipedia.org/wiki/Hexspeak&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It’s pretty interesting, because I remember &lt;a href=&#34;http://www.eecs.harvard.edu/~syrah/os161/&#34;&gt;OS161&lt;/a&gt; from my operating system course where they use 0xDEADBEEF as a value for uninitialized pointers. So I decided to write a small Python program that finds me all the “Hexspeak” words from a regular English dictionary.&lt;/p&gt;

&lt;p&gt;Beginning by finding a plain text English dictionary. I know Linux has a file ‘words’ in the file system somewhere. A little search gives me its location: /usr/share/dict/words&lt;/p&gt;

&lt;p&gt;Now onto Python coding:&lt;/p&gt;

&lt;p&gt;Define a character-to-hex map:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;HEXSPEAK_DICT={&#39;A&#39;:&#39;A&#39;, &#39;B&#39;:&#39;B&#39;, &#39;C&#39;:&#39;C&#39;, &#39;D&#39;:&#39;D&#39;, &#39;E&#39;:&#39;E&#39;, &#39;F&#39;:&#39;F&#39;, &#39;O&#39;:&#39;0&#39;, &#39;L&#39;:&#39;1&#39;, &#39;S&#39;:&#39;5&#39;, &#39;I&#39;:&#39;1&#39;, }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Define a method to open the dictionary and return a list of words:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DICT = &#39;/usr/share/dictdef words(file=DICT):
    f = open(file, &#39;r&#39;)
    retval = f.readlines()
    f.close()
    retval = [ x.strip().upper() for x in retval ]
    return retval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Define a method to print out the collection of hexspeaks&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def print_dict(dict):
    for key in dict.keys():
        print &amp;quot;%-20s\t%s&amp;quot;%(key, dict[key])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The program itself is pretty clear. We go through every character in every word in the dictionary. If the character is not in a permitted Hexspeak character, we through out the word. Otherwise, we take the character and translate it into a hexspeak character if necessary. Finally we print out the whole thing.&lt;/p&gt;

&lt;p&gt;Running it, it gives me a list of hexspeak words. Everything is cool.&lt;/p&gt;

&lt;p&gt;Now, the idea of generator has been around for a while. If you’re operating on a list, instead of loading the list into memory at once, you can use a generator and return one piece at a time, so it can save some resources. Granted, I’ve never used generators before, so I decided to experiement using a generator.&lt;/p&gt;

&lt;p&gt;Here’s the code. Everytime xwords() is called, it returns the next processed value in the list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def xwords(file=DICT):
    f = open(file, &#39;r&#39;)
    retval = f.readlines()
    f.close()

    for rv in retval:
        yield rv.strip().upper()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to modify WORDS to make it point to xwords&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;WORDS = xwords()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running it, it gives the same result. So my experiment with generator succeeded! Hooray!&lt;/p&gt;

&lt;p&gt;However, a little profiling on the program contradicts the intuition that using a generator is faster. I used Python’s timeit module for profiling:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python -m timeit -n 3 &#39;import hexspeak; hexspeak.main()&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using generator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 loops, best of 3: 565 msec per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 loops, best of 3: 549 msec per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmmm, so not only using a generator doesn’t save me any time, it actually got beaten by a tad bit by the plain ol’ list implementation…I’m sure I’m missing some points here. A good topic for a blog post for another day.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a list of &lt;a href=&#34;http://blog.idempotent.ca/2008/09/03/hexspeak-word-list&#34;&gt;Hexspeak words&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>