<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scala on Qiu&#39;s Quibble</title>
    <link>http://blog.idempotent.ca/categories/scala/</link>
    <description>Recent content in Scala on Qiu&#39;s Quibble</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 17 Mar 2011 20:04:00 +0000</lastBuildDate>
    <atom:link href="http://blog.idempotent.ca/categories/scala/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Scala Simple Build Tool -- Not so simple after all</title>
      <link>http://blog.idempotent.ca/2011/03/17/scala-simple-build-tool----not-so-simple-after-all/</link>
      <pubDate>Thu, 17 Mar 2011 20:04:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2011/03/17/scala-simple-build-tool----not-so-simple-after-all/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; I got sbt working by building directly from the master branch from their github repo. The current version is 0.7.5. The tagged 0.9.4 version is actually an older version. Anyway, tried it and kinda loved it.&lt;/p&gt;

&lt;p&gt;This is just another late night rambling&amp;hellip;I was trying to get a proper scala build system setup. I was using Maven scala plugin for a while, but longing for something simpler and more scalanic (is there such a word?). I was pretty &lt;a href=&#34;2011/02/11/cake-the-yummy-clojure-build-system/&#34;&gt;happy&lt;/a&gt; with &lt;a href=&#34;https://github.com/ninjudd/cake&#34;&gt;Cake&lt;/a&gt;, the Clojure build system and expected SBT to allow me to break away from using Maven to build Scala projects&amp;hellip;boy, was I wrong&amp;hellip;&lt;/p&gt;

&lt;p&gt;First off, when you google &amp;lsquo;simple build tool&amp;rsquo;, you get a link to the SBT &lt;a href=&#34;http://code.google.com/p/simple-build-tool/&#34;&gt;Google code home page&lt;/a&gt;. Well, nothing wrong there, except the &amp;ldquo;latest&amp;rdquo; version on Google code was 0.7.4 and it was half a year ago&amp;hellip;Maybe it&amp;rsquo;s not that outdated, so I downloaded it, followed &lt;a href=&#34;http://code.google.com/p/simple-build-tool/wiki/Setup&#34;&gt;this&lt;/a&gt; instruction and setup my &lt;code&gt;~/bin/sbt&lt;/code&gt; script. Running it, it asked me to setup projects, and it only supported up until Scala 2.7.7&amp;hellip;Hrm, 2.8 was out for a while now, so obviously, SBT 0.7.4 isn&amp;rsquo;t the latest. Reading their home page more carefully, they&amp;rsquo;re moving the repository to &lt;a href=&#34;https://github.com/harrah/xsbt&#34;&gt;Github&lt;/a&gt;. Awesome! I&amp;rsquo;d pick Github over Google Code any time too.&lt;/p&gt;

&lt;p&gt;Heading over to their Github repo, and found the latest stable version is 0.9.2. Good! So it should support Scala 2.8 now! Downloaded the zip, unzipped it, and of course it wasn&amp;rsquo;t executable. You need to build it. There&amp;rsquo;s a README.md, so quickly I less&amp;rsquo;ed it. For step 1, it asked me to go to the setup wiki page on Google Code (!), which is the steps I did setting up 0.7.4&amp;hellip;I guess they&amp;rsquo;re using 0.7.4 as a bootstrapping build&amp;hellip;Anyways, I did that. Step 2 was to run &lt;code&gt;sbt update &amp;quot;project Launcher&amp;quot; proguard &amp;quot;project Simple Build Tool&amp;quot; &amp;quot;publish-local&amp;quot;&lt;/code&gt;. Of course it didn&amp;rsquo;t work. It&amp;rsquo;s complained 0.7.4 version of sbt-launch can&amp;rsquo;t download Scala 2.7.7 from any of the repository&amp;hellip;bummer! But hey, I can download Scala 2.7.7 lib from Maven! So I quickly updated pom.xml of one of my projects to use Scala 2.7.7 and did an upgrade. Now 2.7.7 is happily in my local Maven repo. Ran that command again, hooray! It started to build, and judging by the number of packages it&amp;rsquo;s building, &amp;ldquo;simple&amp;rdquo; isn&amp;rsquo;t the first adjective that comes into my mind. Anyway, it&amp;rsquo;s building at least, so even if it&amp;rsquo;s a little complicated, so be it&amp;hellip;Except&amp;hellip;of course it broke half way&amp;hellip; and why?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[info]   Post-analysis: 107 classes.
[info] == Precompiled 2.7.7 / compile ==
[info]
[info]    Precompiled 2.8.0 / compile ...
[info]
[info] == Precompiled 2.8.0 / compile ==
[info]   Source analysis: 9 new/modified, 0 indirectly invalidated, 0 removed.
[info] Compiling main sources...
[warn] there were deprecation warnings; re-run with -deprecation for details
[warn] one warning found
[info] Compilation successful.
[info]   Post-analysis: 108 classes.
[info] == Precompiled 2.8.0 / compile ==
java.lang.OutOfMemoryError: PermGen space
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:616)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ve gotta be kidding me! I set &lt;code&gt;-Xmx512M&lt;/code&gt; and it&amp;rsquo;s not enough? And why is it building every version of Scala &lt;strong&gt;from source&lt;/strong&gt;?? Is there something called a&amp;hellip;JAR?&lt;/p&gt;

&lt;p&gt;Anyway, increased &lt;code&gt;-Xmx&lt;/code&gt; from 512 to 1024M, ran again, wait, and same thing happened again! Out of PermGen space&amp;hellip;urrgh&amp;hellip;&lt;/p&gt;

&lt;p&gt;I decided to give up, at least for the day&amp;hellip; SBT is anything but simple, at least from my experience. I know it&amp;rsquo;s open source and people put efforts into it without compensation, so I shouldn&amp;rsquo;t be critical about it. I&amp;rsquo;ll give it a try again, and hopefully it&amp;rsquo;s worth the time investment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My impression on Scala so far</title>
      <link>http://blog.idempotent.ca/2010/10/07/my-impression-on-scala-so-far/</link>
      <pubDate>Thu, 07 Oct 2010 20:01:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2010/10/07/my-impression-on-scala-so-far/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve been exploring Scala on and off for some time now. Here&amp;rsquo;s my highly subjective and very limited impression of Scala.&lt;/p&gt;

&lt;p&gt;What I like about Scala:&lt;/p&gt;

&lt;h2 id=&#34;0-it-s-statically-typed-language&#34;&gt;0) It&amp;rsquo;s statically-typed language.&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;s right! I don&amp;rsquo;t care what you ninjas say. As much as I love dynamic languages, I just prefer statically typed language for big projects. The benefit of having type information is enormous for a project with a large code base. I know you have to write unit tests for it anyways, but when 80% of your unit test code is checking types, it&amp;rsquo;s just counter-productive.&lt;/p&gt;

&lt;h2 id=&#34;1-the-ability-to-combine-functional-programming-style-with-oop&#34;&gt;1) The ability to combine functional programming style with OOP.&lt;/h2&gt;

&lt;p&gt;This is what Scala is known for - a hybrid language that boasts the better in both OOP world and FP world. I&amp;rsquo;m not a functional programming purist, but I think Scala did a good job blending the functional programming elements into OOP. Writing Scala programs, I find myself much more empowered to be able to choose from both styles where I see fit. The ability to pass functions around and apply high order functions can significantly reduce boilerplate code and visual clutter.&lt;/p&gt;

&lt;h2 id=&#34;2-the-ability-to-create-your-own-control-flow-well-sort-of&#34;&gt;2) The ability to create your own control flow (well, sort of).&lt;/h2&gt;

&lt;p&gt;I had a &lt;a href=&#34;http://reminiscential.wordpress.com/2010/09/29/scala-use-function-currying/&#34;&gt;blog post&lt;/a&gt; about how to use function curry to create a customized control flow. This is very empowering and yet, it&amp;rsquo;s not an one-off syntactic sugar that&amp;rsquo;s sprinkled randomly into the language like some other language would do. Customization of control flow is a result of combining generic language features (such as currying, by-name parameter, implicit conversion, etc).&lt;/p&gt;

&lt;h2 id=&#34;3-object-instead-of-static&#34;&gt;3) Object instead of static&lt;/h2&gt;

&lt;p&gt;Scala does away with the Java static keyword. Instead, it provides &amp;ldquo;object&amp;rdquo; keyword to define a class that only has one instance. It has the same power as singleton design pattern, without the extra boilerplate code. (if you think implementing singleton in Java is simple, think again. Especially in the multi-threaded context). Also, you can use the same construct to define &amp;ldquo;companion&amp;rdquo; objects, which can be used to implement the factory pattern, and put in miscellaneous methods, implicit conversion methods and so on. Extremely powerful yet elegant.&lt;/p&gt;

&lt;h2 id=&#34;4-operator-overloading-well-sort-of&#34;&gt;4) Operator overloading (well, sort of).&lt;/h2&gt;

&lt;p&gt;OK, it&amp;rsquo;s not exactly operator overloading - Scala allows many non-alpha-numeric characters in the method name, so operators are essentially methods. duh! if you think about it&amp;hellip;why should + be treated any different from &lt;code&gt;add()&lt;/code&gt;? Being able to use special characters in method names makes code easy to understand. However, I&amp;rsquo;m a bit disappointed that question mark &lt;code&gt;?&lt;/code&gt; cannot be used in method names&amp;hellip;One of the things I liked about LISP is you can define a function &lt;code&gt;(odd? (x) (...))&lt;/code&gt; and readers immediately know this function returns a boolean. I don&amp;rsquo;t have to ponder whether I should name it &lt;code&gt;isOdd()&lt;/code&gt; or &lt;code&gt;hasChildren()&lt;/code&gt;. Anyway&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;5-traits&#34;&gt;5) Traits&lt;/h2&gt;

&lt;p&gt;In most cases, multiple inheritance is manageable. Seems Java threw the baby out with the bath water - rejecting multiple inheritance completely. It&amp;rsquo;s ironic that the AOP guys cracks open Java classes in the byte code level to do the &amp;ldquo;mixins&amp;rdquo;&amp;hellip;With Scala, this seems to be natural.&lt;/p&gt;

&lt;h2 id=&#34;6-built-in-parser-combinator-library&#34;&gt;6) Built-in parser-combinator library&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s easy to do some non-mission critical parsing using the Scala standard library. The library itself is implemented as an internal DSL such that writing parser rules feels like writing EBNF directly.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what&amp;rsquo;s not so hot for me so far:&lt;/p&gt;

&lt;h2 id=&#34;1-the-generics-still-is-obtrusive-sometimes&#34;&gt;1) The generics still is obtrusive sometimes.&lt;/h2&gt;

&lt;p&gt;That said, however, it&amp;rsquo;s vastly superior than Java&amp;rsquo;s generics system with far better type inferencing. But sometimes, you still have to write down a lot of types especially on a parameterized method. What&amp;rsquo;s worse is because Scala is more strict than Java wrt types, you cannot ignore generic types the way you can in Java code. Moreover, because Scala runs on JVM, and because of type-erasure, you still can&amp;rsquo;t write code such as val t = new T()&amp;hellip;although we can&amp;rsquo;t blame this on Scala.&lt;/p&gt;

&lt;h2 id=&#34;2-the-collection-library&#34;&gt;2) The collection library.&lt;/h2&gt;

&lt;p&gt;For each collection data structure, Scala has the mutable implementation, immutable implementation, and the native Java Collection Library. If you&amp;rsquo;re writing code that calls Java library, very often you have to wrap JCL lists/maps/sets into the Scala ones, because you want to use the nice functional features Scala provides. I&amp;rsquo;m not smart enough to know a better solution to this, I&amp;rsquo;m just merely pointing out a sore spot. Clojure has a very clever and elegant way of integrating JCL data structures into Clojure code, but since Clojure and Scala are vastly different, I don&amp;rsquo;t know how relevant this is.&lt;/p&gt;

&lt;h2 id=&#34;3-start-up-time&#34;&gt;3) Start up time&lt;/h2&gt;

&lt;p&gt;One of Scala&amp;rsquo;s goal is to be able to both scale up and scale down. Scala programs can be run as scripts by the interpreter, but it can&amp;rsquo;t compete with Python or Ruby in terms of development turn-around time in terms of scripting. Again, this is because of the dreadful JVM startup process.&lt;/p&gt;

&lt;h2 id=&#34;4-lack-of-good-tooling&#34;&gt;4) Lack of good tooling&lt;/h2&gt;

&lt;p&gt;The best Scala development environment I found so far is the Scala plugin for IntelliJ. It&amp;rsquo;s still not great for debugging, but for coding and integration with Maven and such, it&amp;rsquo;s great. The Eclipse plugin lags significantly, despite having built a brand new website and seemingly having more resource pour into it&amp;hellip;I know I shouldn&amp;rsquo;t be overly critical of a community effort, but it&amp;rsquo;s just frustrating that it can&amp;rsquo;t even do auto import of classes&amp;hellip;&lt;/p&gt;

&lt;p&gt;Overall, I think Scala really has the potential to become a big name in the programming language landscape. It can do everything Java can and does better. It has so much features that Java doesn&amp;rsquo;t dare to add to keep backward compatibility or keep the language dead simple or politics or whatever reason&amp;hellip;&lt;/p&gt;

&lt;p&gt;Scala is not a hype, but in order to be adopted more rapidly, I think it needs to&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Stablize the language and core library.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tooling, tooling, tooling! Seriously.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Use function currying to reduce repetition and make code clean</title>
      <link>http://blog.idempotent.ca/2010/09/29/use-function-currying-to-reduce-repetition-and-make-code-clean/</link>
      <pubDate>Wed, 29 Sep 2010 19:56:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2010/09/29/use-function-currying-to-reduce-repetition-and-make-code-clean/</guid>
      <description>&lt;p&gt;Lately, I&amp;rsquo;ve been writing a parser using the Scala parser-combinator framework to parse some saves from a game. As a responsible programmer (:P), I write unit tests for each rule. However, I found myself having to write the following code over and over again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@Test
def testRule1() {
  parserRule.apply(new CharSequence(&amp;quot;someInput&amp;quot;)) match {
    case Success(result, _) =&amp;gt; {
      assertEquals(&amp;quot;expected&amp;quot;, result)
      /* other asserts if the result is a collection of something else */
      }
    case NoSuccess(msg, _) =&amp;gt; fail(msg)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s worth noting that you cannot pass in a string value to a &lt;code&gt;Parser&lt;/code&gt;. A parser expects a &lt;code&gt;CharSequence&lt;/code&gt; &lt;code&gt;CharSequenceReader&lt;/code&gt; object. Luckily, with Scala, you can define implicit conversion to turn a string into a &lt;code&gt;CharSequence&lt;/code&gt; &lt;code&gt;CharSequenceReader&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit def str2charSeqReader(v:String) = new CharSequenceReader(v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another goody Scala offers is that &lt;code&gt;obj.apply(arg)&lt;/code&gt; method can be invoked by &lt;code&gt;obj(arg)&lt;/code&gt;, so the above code becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;/* ... */
parserRule(&amp;quot;someInput&amp;quot;) match {
/* ... */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s much cleaner.&lt;/p&gt;

&lt;p&gt;However, the matching part is not clean still. It&amp;rsquo;s not that bad for a single test case, but it&amp;rsquo;s hardly a good practice to copy/paste it all over the test code base. We need to refactor this. The first thing comes to mind is to extract the matching part into a separate method, and let the caller provide the assertion part. Because Scala is a functional language, we can declare the method takes a function as a parameter, instead of using the delegate pattern, creating another class to encapsulate the method to be called, as you would do in Java:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def tryMatch[T](pr:ParseResult[T], f:(T)=&amp;gt;Unit) {
  pr match {
    case Success(r, _) =&amp;gt; f(r)
    case NoSuccess(msg, _) =&amp;gt; fail(msg)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the consumer (the test code) looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@Test
def test1() {
  tryMatch(rule1(&amp;quot;input&amp;quot;), (result)=&amp;gt;{assertEquals(&amp;quot;expected&amp;quot;,result)})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s better, except that when you have multiple assert* methods need to be called, it quickly becomes ugly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@Test
def test2() {
  tryMatch(listRule(&amp;quot;1,2,3,4&amp;quot;), (result)=&amp;gt;{assertEquals(1,result(0));assertEquals(2,result(1));assertEquals(3,result(2));assertEquals(4,result(3))})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do better, we can use &lt;a href=&#34;http://en.wikipedia.org/wiki/Currying&#34;&gt;function currying&lt;/a&gt;. I read about function currying before, but not until now did it dawn on me that I can use this technique to make my code look cleaner. Basically, currying means that a function with n parameters is the same as the function being applied one parameter at a time in succession. e.g., function &lt;code&gt;add(x1:Int,x2:Int,...,xn:Int)&lt;/code&gt; adds all its parameters. &lt;code&gt;add(1,2)=[add(1)](2)&lt;/code&gt;, where &lt;code&gt;add(1)&lt;/code&gt; becomes a partially applied function that takes an integer and returns an integer. Then the partial function is applied to the second parameter which gives the eventual result.&lt;/p&gt;

&lt;p&gt;This is all very theoretical, but the practical implication is that we can transform &lt;code&gt;tryMatch()&lt;/code&gt; method shown above from a method with 2 parameters into a curried function. Why? Because with Scala, when you have a method that only takes a single parameter (as is the case with the partially applied function), you can replace parentheses with curly brackets! Let&amp;rsquo;s see how it works:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def tryMatch[T](pr:ParseResult[T])(f:(T)=&amp;gt;Unit) {
  pr match {
    case Success(r, _) =&amp;gt; f(r)
    case NoSuccess(msg, _) =&amp;gt; fail(msg)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, we break the two parameter definitions. This creates a PartialFunction in Scala. No other code needs to be changed at all. Now we can call tryMatch like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@Test
def testList() {
  tryMatch(listRule(&amp;quot;1 2 3&amp;quot;)) {
    result =&amp;gt; {
      assertEquals(1, result(0))
      assertEquals(2, result(1))
      assertEquals(3, result(2))
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is like creating your own control flow (like try-catch-finally). Ain&amp;rsquo;t that neat?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Finding Happy Numbers using Scala</title>
      <link>http://blog.idempotent.ca/2010/07/23/finding-happy-numbers-using-scala/</link>
      <pubDate>Fri, 23 Jul 2010 19:48:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2010/07/23/finding-happy-numbers-using-scala/</guid>
      <description>&lt;p&gt;The problem was posted on &lt;a href=&#34;http://programmingpraxis.com/2010/07/23/happy-numbers/&#34;&gt;Programming Praxis&lt;/a&gt;. The algorithm itself is pretty straightforward, anyone can do it with a few if/else/fors, but to coerce myself to think functionally, I decide to practice writing it in &lt;a href=&#34;http://www.scala-lang.org&#34;&gt;Scala&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A number is a happy number if the sum of square of its digits eventually arrive at 1. For example, 7=&amp;gt;7&lt;sup&gt;2&lt;/sup&gt;=49=&amp;gt;4&lt;sup&gt;2&lt;/sup&gt;+9&lt;sup&gt;2&lt;/sup&gt;=97=&amp;gt;9&lt;sup&gt;2&lt;/sup&gt;+7&lt;sup&gt;2&lt;/sup&gt;=&amp;gt;130=1&lt;sup&gt;2&lt;/sup&gt;+3&lt;sup&gt;2&lt;/sup&gt;+0&lt;sup&gt;2&lt;/sup&gt;=10=&amp;gt;1&lt;sup&gt;2&lt;/sup&gt;+0&lt;sup&gt;2&lt;/sup&gt;=1, so 7 is a happy number. 17 is not a happy number because by applying the above process, it goes into a loop.&lt;/p&gt;

&lt;p&gt;Step1: calculating the sum of squares of a number&lt;/p&gt;

&lt;p&gt;To get a list of numbers from a given number, we can first convert the number into a string, and then map every character of the string to its corresponding integer value. A more mathematical way is to divide the number continually by 10 until the original number becomes 0, adding the remainder to a list each time&amp;hellip;The first method is easier to visualize, so here it goes:
&lt;code&gt;n.toString.toCharArray.map{digit=&amp;gt;Integer.valueOf(&amp;quot;&amp;quot;+digit)}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s quite wordy but I&amp;rsquo;ve yet to find a better way. I&amp;rsquo;m pretty sure there is so if you know, do inform me.&lt;/p&gt;

&lt;p&gt;Now I need to square each item in the list. So modify the above statement:
&lt;code&gt;n.toString.toCharArray.map{digit=&amp;amp;gt;Math.pow(Integer.valueOf(&amp;quot;&amp;quot;+digit).doubleValue,2.0)}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;One thing bothers me is that I have to explicitly call &lt;code&gt;someInt.doubleValue&lt;/code&gt;&amp;hellip;I thought Scala does the implicit conversion for me? Then I realized &lt;code&gt;Integer.valueOf(...)&lt;/code&gt; gives me &lt;code&gt;java.lang.Integer&lt;/code&gt;, not &lt;code&gt;scala.lang.Int&lt;/code&gt;. So I have to write a implicit conversion function myself:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit def integer2double(i:Integer):Double = i.doubleValue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can get rid of the hideous &lt;code&gt;someInt.doubleValue&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since we&amp;rsquo;re doing implicit conversion already, why not just implicitly convert a numeric character to a double so that it can be accepted by &lt;code&gt;Math.pow&lt;/code&gt;?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit def char2double(ch:Char):Double = Integer.valueOf(&amp;quot;&amp;quot; + ch).doubleValue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the code can be shortened to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;n.toString.toCharArray.map { digit =&amp;amp;gt; Math.pow(digit, 2) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Isn&amp;rsquo;t that sweet? Implicit conversion is cool but it&amp;rsquo;s easy to get carried away and do everything implicit, which makes the code hard to maintain, so there gotta be a balance somewhere. In the scope of this small exercise, I guess it&amp;rsquo;s OK to use it.&lt;/p&gt;

&lt;p&gt;Now that we have the squares of individual digits in a list, we can calculate the sum by reducing or folding it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;((n.toString.toCharArray.map { digit =&amp;amp;gt; Math.pow(digit, 2) }).foldLeft(0.0) { _ + _ }).toInt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;{\_ + \_}&lt;/code&gt; seems a lot like line noise. The underscore converts the statement into a closure. It&amp;rsquo;s a shortcut for &lt;code&gt;(a,b)=&amp;gt;a+b&lt;/code&gt;. It&amp;rsquo;s succinct yet should be used sparingly.&lt;/p&gt;

&lt;p&gt;Step2:return&lt;/p&gt;

&lt;p&gt;lol, yeah, no extra fluff is needed. We can capture the constraints in one return statement, but before that, I need to decide on what states I need to carry on from each recursive step. (You know I&amp;rsquo;m going to use recursion, don&amp;rsquo;t you? :P)&lt;/p&gt;

&lt;p&gt;There are a couple of states involved:
1. the limit. It&amp;rsquo;s the number of steps we allow before the final &amp;ldquo;1&amp;rdquo; is reached. It took number seven 5 steps to reach 1. This variable is the cut-off: if the given number can&amp;rsquo;t reach 1 before the limit, it&amp;rsquo;s considered unhappy (return &lt;code&gt;false&lt;/code&gt;)
2. the current number of steps
3. the set of numbers already appeared. In the case of seven, the set is &lt;code&gt;{49 97 130 10}&lt;/code&gt;. This set is used to determine if the calculations fall into a loop. If the current calculated number appears in this set, the original number is unhappy.&lt;/p&gt;

&lt;p&gt;So here&amp;rsquo;s our method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def isHappyNumber(n:Int, limit:Int, numOfTries:Int, alreadySeen:Set[Int]):Boolean = {
val sos = ((n.toString.toCharArray.map { digit =&amp;amp;gt; Math.pow(digit, 2) }).foldLeft(0.0) { _ + _ }).toInt
return sos == 1 ? true : (!alreadySeen.contains(sos) &amp;amp;amp;&amp;amp;amp; numOfTries+1 &amp;amp;lt;= limit &amp;amp;amp;&amp;amp;amp; isHappyNumber(sos, limit, numOfTries+1, alreadySeen+sos))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second line basically says: when &lt;code&gt;sos&lt;/code&gt; (sum of squares) is 1, return &lt;code&gt;true&lt;/code&gt;, otherwise, is the number already in the set of numbers seen during the calculation?, if not, does the number of calculation exceed the limit? if not, repeat the calculation, with sos being the &amp;ldquo;original&amp;rdquo; number, increase the counter and put sos in the &lt;code&gt;alreadySeen&lt;/code&gt; set.&lt;/p&gt;

&lt;p&gt;Note that this is a &lt;a href=&#34;http://en.wikipedia.org/wiki/Tail_recursion&#34;&gt;Tail recursion&lt;/a&gt; function, we can add &lt;code&gt;@tailrec&lt;/code&gt; annotation to the method to let the compiler optimize it - turn the recursion into a loop so that it won&amp;rsquo;t grow in stack.&lt;/p&gt;

&lt;p&gt;Now that we&amp;rsquo;ve had the body of the function, we can write an overload method that provides initial values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def isHappyNumber(n:Int):Boolean = isHappyNumber(n, 10, 0, Set[Int]())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To find all happy numbers between 1 and 100:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;println (1 to 100 filter { isHappyNumber(_) })
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>