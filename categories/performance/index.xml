<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Qiu&#39;s Quibble</title>
    <link>http://blog.idempotent.ca/categories/performance/index.xml</link>
    <description>Recent content on Qiu&#39;s Quibble</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.idempotent.ca/categories/performance/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>CouchDB Indexing Benchmark</title>
      <link>http://blog.idempotent.ca/2016/12/19/couchdb-indexing-benchmark/</link>
      <pubDate>Mon, 19 Dec 2016 23:34:56 -0500</pubDate>
      
      <guid>http://blog.idempotent.ca/2016/12/19/couchdb-indexing-benchmark/</guid>
      <description>

&lt;p&gt;In the &lt;a href=&#34;2016-11-16-couchdb-index-view-benchmark&#34;&gt;last post&lt;/a&gt;, we discussed how CouchDB&amp;rsquo;s external query server works by examining the raw protocol. In this post, we&amp;rsquo;re going to take a look at the performance of different query servers.&lt;/p&gt;

&lt;p&gt;The code used in this benchmarking is &lt;a href=&#34;https://gist.github.com/kevinjqiu/dd461b36a6f1d6d755d7a317d8f98b75&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I listed below the method of the benchmark in detail. If you want you can &lt;a href=&#34;#result-comparison&#34;&gt;jump to conclusion&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;the-setup&#34;&gt;The Setup&lt;/h1&gt;

&lt;p&gt;The benchmarks are done on my laptop (Intel 6th-gen i7 processor, 8G RAM, SSD) with CouchDB 1.6 in a docker container. Since we&amp;rsquo;re benchmarking python views as well, we&amp;rsquo;re going to customize the docker image add python query server to it. Here&amp;rsquo;s the dockerfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM couchdb
RUN apt-get update -yqq &amp;amp;&amp;amp; apt-get install -y python python-pip
RUN pip install couchdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build a new image with that dockerfile, and start a couchdb instance with (assuming you named your image &lt;code&gt;couchdb-python&lt;/code&gt; from the last step):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -p 9999:5984 -d -v $(pwd)/data:/usr/local/var/lib/couchdb couchdb-python 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your couchdb instance will be accessible via &lt;code&gt;localhost:9999&lt;/code&gt;. By default, the container is started in the admin party mode (everybody is an admin) but since we use it only for the purpose of testing, we won&amp;rsquo;t bother with setting up username/password.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://localhost:9999/
{&amp;quot;couchdb&amp;quot;:&amp;quot;Welcome&amp;quot;,&amp;quot;uuid&amp;quot;:&amp;quot;47a7b22e608a73fc2214ed13063923b8&amp;quot;,&amp;quot;version&amp;quot;:&amp;quot;1.6.1&amp;quot;,&amp;quot;vendor&amp;quot;:{&amp;quot;version&amp;quot;:&amp;quot;1.6.1&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;The Apache Software Foundation&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;preparing-the-data&#34;&gt;Preparing the data&lt;/h2&gt;

&lt;p&gt;The data we&amp;rsquo;re working have simple structures. We&amp;rsquo;ll be generating data of the following form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;metadata&amp;quot;: {
        &amp;quot;docType&amp;quot;: &amp;quot;userscore&amp;quot;,
        &amp;quot;createdAt&amp;quot;: &amp;quot;2016-12-19T19:28:14.000&amp;quot;
    },
    &amp;quot;username&amp;quot;: &amp;quot;barry&amp;quot;,
    &amp;quot;score&amp;quot;: 912
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are storing the name of the user along with their score in the document, whatever that is. It&amp;rsquo;s a contrived example so bear with me :)&lt;/p&gt;

&lt;p&gt;To populate a dataset for our benchmarking, let&amp;rsquo;s use a script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import string
import sys
import requests
import random
import datetime
from multiprocessing import Pool


DB_URL = &#39;http://localhost:9999/test&#39;


def random_name():
    generate_character = lambda _: random.choice(string.ascii_letters)
    return &#39;&#39;.join(map(generate_character, range(6)))


def random_date():
    # get a random date from within last year
    today = datetime.date.today()
    that_day = today - datetime.timedelta(days=random.randint(0, 366))
    return datetime.datetime.strftime(that_day, &#39;%Y-%m-%d&#39;)


def generate_doc(_):
    doc = {
        &#39;metadata&#39;: {
            &#39;docType&#39;: &#39;score&#39;,
            &#39;createdAt&#39;: random_date()
        },
        &#39;username&#39;: random_name(),
        &#39;score&#39;: random.randint(0, 5000)
    }
    response = requests.post(DB_URL, json=doc)
    response.raise_for_status()


if __name__ == &#39;__main__&#39;:
    num_of_docs = int(sys.argv[1])
    requests.delete(DB_URL)  # delete the database if it exists already
    response = requests.put(DB_URL)     # create the test database
    print(&#39;Generating {} docs&#39;.format(num_of_docs))
    pool = Pool(50)
    pool.map(generate_doc, range(num_of_docs))
    stats = requests.get(&#39;{}/&#39;.format(DB_URL)).json()
    print(&#39;doc_count: {}&#39;.format(stats[&#39;doc_count&#39;]))
    print(&#39;disk_size: {}&#39;.format(stats[&#39;disk_size&#39;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can seed the database by using: &lt;code&gt;python /path/to/script.py 100000&lt;/code&gt; to create 100k documents. This is likely to take a while:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python generate_data.py 100000
doc_count: 100000
disk_size: 111153301
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, now we have a test database with 100000 documents.&lt;/p&gt;

&lt;h2 id=&#34;setup-python-query-server&#34;&gt;Setup Python Query Server&lt;/h2&gt;

&lt;p&gt;Python query server needs to be activated. You can either change it in the config file on the container and restart it or change it on the fly with the &lt;code&gt;_config&lt;/code&gt; endpoint.&lt;/p&gt;

&lt;p&gt;We can take a look at what&amp;rsquo;s currently configured:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://localhost:9999/_config/query_servers
{&amp;quot;javascript&amp;quot;:&amp;quot;/usr/local/bin/couchjs /usr/local/share/couchdb/server/main.js&amp;quot;,&amp;quot;coffeescript&amp;quot;:&amp;quot;/usr/local/bin/couchjs /usr/local/share/couchdb/server/main-coffee.js&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s add python query server there:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -XPUT -H&amp;quot;Content-Type: application/json&amp;quot; http://localhost:9999/_config/query_servers/python -d&#39;&amp;quot;/usr/bin/python /usr/local/bin/couchpy&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and verify that it&amp;rsquo;s saved:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://localhost:9999/_config/query_servers
{&amp;quot;javascript&amp;quot;:&amp;quot;/usr/local/bin/couchjs /usr/local/share/couchdb/server/main.js&amp;quot;,&amp;quot;coffeescript&amp;quot;:&amp;quot;/usr/local/bin/couchjs /usr/local/share/couchdb/server/main-coffee.js&amp;quot;,&amp;quot;python&amp;quot;:&amp;quot;/usr/bin/python /usr/local/bin/couchpy&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;benchmark-javascript-views&#34;&gt;Benchmark Javascript views&lt;/h2&gt;

&lt;p&gt;The view we are going to write is to calculate the total score of all users for a given month. We will have a map function to map each document to &lt;code&gt;([Year, Month], Score)&lt;/code&gt; and a reduce function to sum up all the scores.&lt;/p&gt;

&lt;h3 id=&#34;map-reduce-function&#34;&gt;Map/Reduce function&lt;/h3&gt;

&lt;p&gt;The map function written in Javascript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function(doc) {
    if (doc.metadata &amp;amp;&amp;amp; doc.metadata.createdAt) {
        var parts = doc.metadata.createdAt.split(&amp;quot;-&amp;quot;),
            year = parts[0],
            month = parts[1];
        emit([year, month], doc.score);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the reduce function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function(keys, values, rereduce) {
    return sum(values);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s save it as a design doc &lt;code&gt;_design/scoresByMonthJS:scoresByMonth&lt;/code&gt;. You can use either Futon or curl or &lt;a href=&#34;https://github.com/kevinjqiu/cdbcli&#34;&gt;cdbcli&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To invoke the view, we can send a curl request to &lt;code&gt;http://localhost:9999/test/_design/scoresByMonthJS/_view/scoresByMonth?limit=11&amp;amp;group=true&lt;/code&gt;. However, keep in mind that whenever a view is invoked, the indexer will kick in and index any new changes since the last index. Because this is our first invocation of the view, it will index all changes (100K) so it&amp;rsquo;s going to take some time. This will be the opportunity for us to observe the speed of indexing, so before we invoke that, let&amp;rsquo;s get our script ready to monitor the speed of the indexing.&lt;/p&gt;

&lt;h3 id=&#34;monitor-changes-per-second-metric&#34;&gt;Monitor changes-per-second metric&lt;/h3&gt;

&lt;p&gt;CouchDB exposes its indexing status through the &lt;code&gt;/_active_tasks&lt;/code&gt; endpoint. It contains the number of changes to be indexed in total and the number of changes already indexed. From that, we can calculate the changes per second as our benchmark. As stated before, you can find the code &lt;a href=&#34;https://gist.github.com/kevinjqiu/dd461b36a6f1d6d755d7a317d8f98b75&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python cps.py _design/scoresByMonthJS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This starts a monitoring script on the specified design doc, and prints out changes per second number every 1 second.&lt;/p&gt;

&lt;p&gt;With this script running, in another terminal, let&amp;rsquo;s trigger the view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl &amp;quot;http://localhost:9999/test/_design/scoresByMonthJS/_view/scoresByMonth?limit=11&amp;amp;group=true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go back to the terminal where the monitoring script is run. We will see that it started to print out cps values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python cps.py _design/scoresByMonthJS
design doc: _design/scoresByMonthJS
Press Ctrl+C to exit
c/s = 4141.00
c/s = 7373.00
c/s = 7120.50
c/s = 5378.25
c/s = 5534.80
c/s = 5605.50
c/s = 5670.43
c/s = 5719.12
c/s = 5757.00
c/s = 6060.00
c/s = 6110.50
c/s = 6041.64
c/s = 5570.54
c/s = 5605.50
c/s = 5629.07
c/s = 5649.69
c/s = 5632.24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And when the indexing is complete, press Ctrl+C and the average will be printed out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^Caverage = 5799.93
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and in the other terminal, we will see the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl &amp;quot;http://localhost:9999/test/_design/scoresByMonthJS/_view/scoresByMonth?limit=11&amp;amp;group=true&amp;quot;

{&amp;quot;rows&amp;quot;:[
{&amp;quot;key&amp;quot;:[&amp;quot;2015&amp;quot;,&amp;quot;12&amp;quot;],&amp;quot;value&amp;quot;:8241946},
{&amp;quot;key&amp;quot;:[&amp;quot;2016&amp;quot;,&amp;quot;01&amp;quot;],&amp;quot;value&amp;quot;:20924965},
{&amp;quot;key&amp;quot;:[&amp;quot;2016&amp;quot;,&amp;quot;02&amp;quot;],&amp;quot;value&amp;quot;:19422002},
{&amp;quot;key&amp;quot;:[&amp;quot;2016&amp;quot;,&amp;quot;03&amp;quot;],&amp;quot;value&amp;quot;:21217217},
{&amp;quot;key&amp;quot;:[&amp;quot;2016&amp;quot;,&amp;quot;04&amp;quot;],&amp;quot;value&amp;quot;:20588868},
{&amp;quot;key&amp;quot;:[&amp;quot;2016&amp;quot;,&amp;quot;05&amp;quot;],&amp;quot;value&amp;quot;:21011332},
{&amp;quot;key&amp;quot;:[&amp;quot;2016&amp;quot;,&amp;quot;06&amp;quot;],&amp;quot;value&amp;quot;:20404601},
{&amp;quot;key&amp;quot;:[&amp;quot;2016&amp;quot;,&amp;quot;07&amp;quot;],&amp;quot;value&amp;quot;:20831013},
{&amp;quot;key&amp;quot;:[&amp;quot;2016&amp;quot;,&amp;quot;08&amp;quot;],&amp;quot;value&amp;quot;:21446896},
{&amp;quot;key&amp;quot;:[&amp;quot;2016&amp;quot;,&amp;quot;09&amp;quot;],&amp;quot;value&amp;quot;:20340594},
{&amp;quot;key&amp;quot;:[&amp;quot;2016&amp;quot;,&amp;quot;10&amp;quot;],&amp;quot;value&amp;quot;:20993863}
]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the average for a Javascript view is around 5.8k changes per second.&lt;/p&gt;

&lt;h3 id=&#34;builtin-reducer&#34;&gt;Builtin Reducer&lt;/h3&gt;

&lt;p&gt;Many of you with CouchDB knowledge will quick to point out that I used a Javascript function as reducer to calculate the sum of the values. This is not very efficient, since (1) data will have to be serialized and sent to the external query server to calculate the result and (2) Javascript isn&amp;rsquo;t the fastest at mathematics (the default couchjs is using the Spider Monkey engine). We can cut short this loop by using the builtin &lt;code&gt;_sum&lt;/code&gt; reducer, which is written in Erlang and run on the same runtime as CouchDB itself, therefore, cut the roundtrip to the query server plus the serialization/deserialization cost.&lt;/p&gt;

&lt;p&gt;To use it, simply change the reducer function to &lt;code&gt;_sum&lt;/code&gt;. Start the monitoring and trigger indexing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;design doc: _design/scoresByMonthJS
Press Ctrl+C to exit
c/s = 3333.00
c/s = 9696.00
c/s = 11312.00
c/s = 11850.67
c/s = 12069.50
c/s = 12221.00
c/s = 12338.83
c/s = 12365.29
c/s = 11741.25
^Caverage = 10769.73
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, by simply changing the reducer from external to builtin, the indexing speed improved &lt;code&gt;185.5%&lt;/code&gt;!&lt;/p&gt;

&lt;h2 id=&#34;benchmark-python-views&#34;&gt;Benchmark Python views&lt;/h2&gt;

&lt;h3 id=&#34;map-reduce&#34;&gt;Map/reduce&lt;/h3&gt;

&lt;p&gt;We save the following map/reduce function as &lt;code&gt;_design/scoresByMonthPY&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;Map:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def map(doc):
    if &#39;metadata&#39; in doc and &#39;createdAt&#39; in doc[&#39;metadata&#39;]:
        created_at = doc[&#39;metadata&#39;][&#39;createdAt&#39;]
        year, month, _ = created_at.split(&#39;-&#39;)
        yield [year, month], doc[&#39;score&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reduce:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def reduce(keys, values, rereduce):
    return sum(values)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We use a sub-optimal reducer to draw comparison with the first Javascript benchmark we did before. And it turned out that Python views are slightly more performant:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python cps.py _design/scoresByMonthPY
design doc: _design/scoresByMonthPY
Press Ctrl+C to exit
c/s = 2323.00
c/s = 6969.00
c/s = 8433.50
c/s = 8719.67
c/s = 8913.25
c/s = 8948.60
c/s = 8972.17
c/s = 9003.43
c/s = 9014.25
c/s = 9011.44
c/s = 9019.30
^Caverage = 8120.69
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s switch the reducer to CouchDB&amp;rsquo;s builtin &lt;code&gt;_sum&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;design doc: _design/scoresByMonthPY
Press Ctrl+C to exit
c/s = 5959.00
c/s = 8938.50
c/s = 9864.33
c/s = 10403.00
c/s = 11842.25
c/s = 11837.20
c/s = 11833.83
c/s = 11802.57
c/s = 11753.88
^Caverage = 10470.51
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result isn&amp;rsquo;t that different from Javascript map function with builtin reducer.&lt;/p&gt;

&lt;h3 id=&#34;improving-couchpy&#34;&gt;Improving couchpy&lt;/h3&gt;

&lt;h4 id=&#34;simplejson&#34;&gt;simplejson&lt;/h4&gt;

&lt;p&gt;Since an external query server need to deserialize JSON input from CouchDB and serialize the result back into JSON form to be consumed by CouchDB, the implementation of the JSON module could potentially make a difference in performance. As &lt;code&gt;couchpy&lt;/code&gt; defaults to use the system &lt;code&gt;json&lt;/code&gt; module provided by the Python distribution, it&amp;rsquo;s not the most performant implementation. &lt;code&gt;simplejson&lt;/code&gt; is a drop-in replacement for the Python&amp;rsquo;s &lt;code&gt;json&lt;/code&gt; module which uses a C implementation for json encoding/decoding. Let&amp;rsquo;s try that.&lt;/p&gt;

&lt;p&gt;First, we need to install simplejson (which requires Python C headers to be installed. On Debian, install &lt;code&gt;python-dev&lt;/code&gt; package) on the container and then modify the config to use &lt;code&gt;couchpy --json-module=simplejson&lt;/code&gt; as the Python query server command.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python cps.py _design/scoresByMonthPY
design doc: _design/scoresByMonthPY
Press Ctrl+C to exit
c/s = 5454.00
c/s = 11514.00
c/s = 12019.00
c/s = 12120.00
c/s = 9675.80
c/s = 9999.00
c/s = 10316.43
c/s = 10516.62
^Caverage = 10201.86
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interesting&amp;hellip; &lt;code&gt;simplejson&lt;/code&gt; performance is only on-par with dthe stock &lt;code&gt;json&lt;/code&gt; module. That&amp;rsquo;s a little unexpected. However, if you look at &lt;code&gt;top&lt;/code&gt; while the indexer is running, the Python process never consumes more than 60% of CPU time.&lt;/p&gt;

&lt;h4 id=&#34;pypy&#34;&gt;PyPy&lt;/h4&gt;

&lt;p&gt;We can also try to use pypy as our interpreter. PyPy is an alternative implementation of Python that adds a Just-In-Time compiler. The benchmark showed a marginal improvement over CPython.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python cps.py _design/scoresByMonthPY
design doc: _design/scoresByMonthPY
Press Ctrl+C to exit
c/s = 6767.00
c/s = 10453.50
c/s = 11648.67
c/s = 12195.75
c/s = 12524.00
c/s = 13816.80
c/s = 12841.43
^Caverage = 11463.88
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The performance for PyPy isn&amp;rsquo;t much greater is probably due to the fact how the CouchDB query protocol works: it sends the query server one document at a time to run the map function over. JIT excels at loops but at each request/response cycle, the query server only operates one document at a time. The JIT wasn&amp;rsquo;t given a chance to warmup. That was my conjecture anyway, as I&amp;rsquo;m not an expert on PyPy&amp;rsquo;s JIT internals.&lt;/p&gt;

&lt;h2 id=&#34;native-views&#34;&gt;Native Views&lt;/h2&gt;

&lt;p&gt;As we can see, the performance of external query servers don&amp;rsquo;t vary by a lot. Another interesting observation is that the query server process was not fully saturated, doesn&amp;rsquo;t matter when it&amp;rsquo;s Javascript, Python, or PyPy.&lt;/p&gt;

&lt;p&gt;Looking at the &lt;a href=&#34;2016-11-16-couchdb-index-view-benchmark&#34;&gt;CouchDB query protocol&lt;/a&gt;, it seemed that the process of feeding data to the external query server is the bottleneck: The CouchDB erlang process serializes the document from Erlang to JSON, send JSON to the query server&amp;rsquo;s process. The query server deserializes JSON, run the map/reduce function and serializes that into JSON to be fed back to the CouchDB process, and the CouchDB process deserializes that back into Erlang&amp;rsquo;s data structure. Wouldn&amp;rsquo;t it be great if all of that can happen within the same runtime as the CouchDB process? That brought me to research writing CouchDB views in Erlang, and indeed, there is &lt;a href=&#34;https://wiki.apache.org/couchdb/EnableErlangViews&#34;&gt;such a thing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Having dabbled with Erlang at the beginning of my career, I&amp;rsquo;m not put off by the idea. However, Erlang is not a beginner-friendly language if you&amp;rsquo;re coming from the C/C++/Java line.&lt;/p&gt;

&lt;p&gt;First we need to enable Erlang native query server in the configs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -XPUT -H &amp;quot;Content-Type:application/json&amp;quot; http://localhost:9999/_config/native_query_servers/erlang -d&#39;&amp;quot;{couch_native_process, start_link, []}&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;map&#34;&gt;Map&lt;/h3&gt;

&lt;p&gt;It takes some trial-and-error but there it is, the Erlang version of the map function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun({Doc})-&amp;gt;
    case proplists:get_value(&amp;lt;&amp;lt;&amp;quot;metadata&amp;quot;&amp;gt;&amp;gt;, Doc) of
        {Metadata} -&amp;gt;
            CreatedAt = proplists:get_value(&amp;lt;&amp;lt;&amp;quot;createdAt&amp;quot;&amp;gt;&amp;gt;, Metadata),
            case string:tokens(binary_to_list(CreatedAt), &amp;quot;-&amp;quot;) of
                [Year, Month|_] -&amp;gt; Emit([list_to_binary(Year), list_to_binary(Month)], proplists:get_value(&amp;lt;&amp;lt;&amp;quot;score&amp;quot;&amp;gt;&amp;gt;, Doc))
        end
    end
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CouchDB documents are represented in Erlang as a tuple of lists (proplists), and hence we use &lt;a href=&#34;http://erlang.org/doc/man/proplists.html&#34;&gt;&lt;code&gt;proplists:get_value&lt;/code&gt;&lt;/a&gt; to extract values given certain &amp;ldquo;keys&amp;rdquo;. Erlang has great pattern-matching feature so we use it to further extract &lt;code&gt;Year&lt;/code&gt; and &lt;code&gt;Month&lt;/code&gt; from the split string. Strings in Erlang are represented as a list of binary numbers (referring to their codepoint). &lt;code&gt;&amp;lt;&amp;lt;&amp;quot;createdAt&amp;quot;&amp;gt;&amp;gt;&lt;/code&gt; is the literal to convert the string &lt;code&gt;createdAt&lt;/code&gt; to its binary list equivalent to match the type of the document object. Again, I&amp;rsquo;m not an Erlang expert, so please point out my inaccuracies with regard to the language.&lt;/p&gt;

&lt;h3 id=&#34;reduce&#34;&gt;Reduce&lt;/h3&gt;

&lt;p&gt;We will use the same reducer &lt;code&gt;_sum&lt;/code&gt; as it has served us well.&lt;/p&gt;

&lt;h3 id=&#34;benchmark&#34;&gt;Benchmark&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ python cps.py _design/scoresByMonthERL
design doc: _design/scoresByMonthERL
Press Ctrl+C to exit
c/s = 19821.25
^Caverage = 19821.25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There you have it! The Erlang view is about 173% as fast as the previous fastest (PyPy) option.&lt;/p&gt;

&lt;p&gt;One &lt;strong&gt;caveat&lt;/strong&gt; about using Erlang native views: since it&amp;rsquo;s running on the same runtime as CouchDB and is not sandboxed, it&amp;rsquo;s able to access CouchDB&amp;rsquo;s internal API and call Erlang functions that maybe destructive. Do not run untrusted view functions directly.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at where we stand in terms of indexer option and performance:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Option&lt;/th&gt;
&lt;th&gt;Average c/s&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;couchjs/external reducer&lt;/td&gt;
&lt;td&gt;5799.93&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchjs/builtin reducer&lt;/td&gt;
&lt;td&gt;10769.73&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/external reducer&lt;/td&gt;
&lt;td&gt;8120.69&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/builtin reducer&lt;/td&gt;
&lt;td&gt;10470.51&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/simplejson/builtin reducer&lt;/td&gt;
&lt;td&gt;10201.86&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/pypy/builtin reducer&lt;/td&gt;
&lt;td&gt;11463.88&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;erlang native view&lt;/td&gt;
&lt;td&gt;19821.25&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;benchmark-with-bigger-documents&#34;&gt;Benchmark with bigger documents&lt;/h2&gt;

&lt;p&gt;The above set of tests are done on documents with smallish size. Let&amp;rsquo;s add some junk data to the documents. I modified the document generation procedure to add in some arbitrary string properties so now the average document size is about 300k.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.idempotent.ca/images/couchdb-indexing-benchmark.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Benchmark&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def generate_doc(i):
    doc = {
        &#39;metadata&#39;: {
            &#39;docType&#39;: &#39;score&#39;,
            &#39;createdAt&#39;: random_date()
        },
        &#39;username&#39;: random_str(),
        &#39;score&#39;: random.randint(0, 5000),
        &#39;custom_data&#39;: {
        }
    }

    for _ in range(random.randint(0, 100)):
        doc[&#39;custom_data&#39;][random_str()] = \
            base64.b64encode((random_str() * 100).encode(&#39;ascii&#39;)).decode(&#39;ascii&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with this new database, rerun the above benchmark. We have:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Option&lt;/th&gt;
&lt;th&gt;Average c/s&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;couchjs/external reducer&lt;/td&gt;
&lt;td&gt;648.50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchjs/builtin reducer&lt;/td&gt;
&lt;td&gt;727.18&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/external reducer&lt;/td&gt;
&lt;td&gt;1564.38&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/builtin reducer&lt;/td&gt;
&lt;td&gt;1590.20&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/simplejson/builtin reducer&lt;/td&gt;
&lt;td&gt;2352.69&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/pypy/builtin reducer&lt;/td&gt;
&lt;td&gt;1265.20&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;erlang native view&lt;/td&gt;
&lt;td&gt;9363.44&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.idempotent.ca/images/couchdb-indexing-benchmark-300k.png&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;h4&gt;Benchmark&lt;/h4&gt;
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h2 id=&#34;result-comparison&#34;&gt;Result Comparison&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s combine the two tables together:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Option&lt;/th&gt;
&lt;th&gt;cps@1k&lt;/th&gt;
&lt;th&gt;cps@300k&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;couchjs/external reducer&lt;/td&gt;
&lt;td&gt;5799.93&lt;/td&gt;
&lt;td&gt;648.50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchjs/builtin reducer&lt;/td&gt;
&lt;td&gt;10769.73&lt;/td&gt;
&lt;td&gt;727.18&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/external reducer&lt;/td&gt;
&lt;td&gt;8120.69&lt;/td&gt;
&lt;td&gt;1564.38&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/builtin reducer&lt;/td&gt;
&lt;td&gt;10470.51&lt;/td&gt;
&lt;td&gt;1590.20&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/simplejson/builtin reducer&lt;/td&gt;
&lt;td&gt;10201.86&lt;/td&gt;
&lt;td&gt;2352.69&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;couchpy/pypy/builtin reducer&lt;/td&gt;
&lt;td&gt;11463.88&lt;/td&gt;
&lt;td&gt;1265.20&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;erlang native view&lt;/td&gt;
&lt;td&gt;19821.25&lt;/td&gt;
&lt;td&gt;9363.44&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Here are some conclusion we can draw from this experiment:
- Native Erlang views are the fastest by a large margin.
- Native Erlang views&amp;rsquo; advantage is even more obvious when documents are larger
- Avoid external reducer as much as you can. (i.e., Use the builtin reducer whenever you can)
- PyPy does not offer performance improvements for Python views (in some cases, it&amp;rsquo;s worse) probably due to the way query protocol works
- The default Javascript view performance isn&amp;rsquo;t great
- Use simplejson for Python view when documents are larger&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>