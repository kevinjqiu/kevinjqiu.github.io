<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Functional Programming on Qiu&#39;s Quibble</title>
    <link>http://blog.idempotent.ca/categories/functional-programming/</link>
    <description>Recent content in Functional Programming on Qiu&#39;s Quibble</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Oct 2010 20:06:00 +0000</lastBuildDate>
    <atom:link href="http://blog.idempotent.ca/categories/functional-programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Use Python decorator to curry functions</title>
      <link>http://blog.idempotent.ca/2010/10/22/use-python-decorator-to-curry-functions/</link>
      <pubDate>Fri, 22 Oct 2010 20:06:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2010/10/22/use-python-decorator-to-curry-functions/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s been a while since the last time I wrote about Python. This morning, I was listening to a podcast on my way to work. They were discussing functional programming and dynamic languages&amp;hellip;I learned Python before I went into Computer Science, and then I learned about functional programming and through learning of Scala and Clojure, my functional programming concepts have been enriched. As I was listening, it suddenly appeared to me that there isn&amp;rsquo;t a way in Python to &lt;a href=&#34;http://en.wikipedia.org/wiki/Currying&#34;&gt;curry&lt;/a&gt; a function. Not that it&amp;rsquo;s critical to everyday development, but wouldn&amp;rsquo;t it be neat if I can curry a function in Python?&lt;/p&gt;

&lt;p&gt;Then the hosts of the podcast discussed how dynamic languages are so flexible that you can pretty much do anything to it. &amp;ldquo;You can take a function as parameter, return a function from a function, and so on.&amp;rdquo; Hey, isn&amp;rsquo;t that what Python&amp;rsquo;s &lt;a href=&#34;http://www.artima.com/weblogs/viewpost.jsp?thread=240808&#34;&gt;decorator&lt;/a&gt; can do? I learned decorators before, but I haven&amp;rsquo;t used it beyond the scope of creating properties and certainly haven&amp;rsquo;t written any decorators. I thought this would be a good exercise for learning decorators.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simple example of what function currying: suppose you have a method&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add(x,y):
  return x+y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then calling &lt;code&gt;add(1,2)&lt;/code&gt; should be the same as &lt;code&gt;add(1)(2)&lt;/code&gt;. &lt;code&gt;add(1)&lt;/code&gt; is what they call a partially applied function. It&amp;rsquo;s a function that takes one parameter.&lt;/p&gt;

&lt;p&gt;Our goal here is to write a decorator &amp;ldquo;curried&amp;rdquo; that takes a function with n parameters and transform it in a way that can be applied n times and get the final result.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start with unit tests first:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import unittest

class CurryTest(unittest.TestCase):

    def test_with_no_args(self):
        @curried
        def do_nothing():
            return &amp;quot;&amp;quot;
        self.assertEquals(&amp;quot;&amp;quot;, do_nothing())

    def test_with_int_args(self):
        @curried
        def add_int(x,y):
            return x+y
        self.assertEquals(3, add_int(1)(2))
    def test_with_str_args(self):
        @curried
        def add_str(x,y):
            return &amp;quot;%s%s&amp;quot;%(x,y)
        self.assertEquals(&amp;quot;ab&amp;quot;, add_str(&amp;quot;a&amp;quot;)(&amp;quot;b&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we make sure that a currying on a function takes no parameter is valid but should be a pass through, and also the &amp;ldquo;curried&amp;rdquo; decorator can be applied to any function with arguments (excluding positional arguments and keyword arguments)&lt;/p&gt;

&lt;p&gt;A decorator is simply a function that takes a function as parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def curried(fn):
  pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;@curried&lt;/code&gt; is simply a syntactic sugar for:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fn(...): ...
fn=curried(fn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, now we can write &lt;code&gt;curried&lt;/code&gt; decorator.
To make the test for function with no argument pass, in &lt;code&gt;curried()&lt;/code&gt; function, we can test to see if fn has arguments. Python&amp;rsquo;s standard library provides &lt;code&gt;inspect.getargspec&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def curried(fn):
  argspec = inspect.getargspec(fn)
  if len(argspec.args)==0:
    return fn
  else:
    # later
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the first test passes.&lt;/p&gt;

&lt;p&gt;For the other two cases, here&amp;rsquo;s the strategy. In Python, when a class defines &lt;code&gt;__call__&lt;/code&gt; method, the instance of that class is said to be &amp;ldquo;callable&amp;rdquo;. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class A(object):
  def __call__(self, arg):
    return arg

f=A()
f(&amp;quot;echo&amp;quot;)  # this gives you &amp;quot;echo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is very similar to Scala&amp;rsquo;s &lt;code&gt;apply()&lt;/code&gt; function. Now that we have this in our inventory, we can define a &lt;code&gt;PartialFunction&lt;/code&gt; class, take all the required parameters of the original function, and allow them to be applied one at a time. So the &lt;code&gt;__call__&lt;/code&gt; method of PartialFunc will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __call__(self, value):
  # Xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If all the required parameters are passed in, &lt;code&gt;PartialFunc&lt;/code&gt; should evaluate the original function with the complete argument list. Otherwise, &lt;code&gt;PartialFunc&lt;/code&gt; stores the parameter in an instance variable, and returns itself.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the complete code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class PartialFunc(object):
    def __init__(self, fn, argspec):
        self.fn = fn
        self.argspec = argspec
        self.args = []

    def __call__(self, value):
        self.args.append(value)
        if len(self.args) == len(self.argspec.args):
            arglist = &amp;quot;,&amp;quot;.join([&amp;quot;self.args[%d]&amp;quot;%i for i in range(0, len(self.args))])
            return eval(&amp;quot;self.fn(&amp;quot; + arglist + &amp;quot;)&amp;quot;)
        else:
            return self
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the curried decorator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def curried(fn):
    argspec = inspect.getargspec(fn)
    if len(argspec.args) == 0:
        return fn
    else:
        return PartialFunc(fn, argspec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s pretty straightforward. When the parameters are complete, I construct a python statement that calls the original function with the complete argument list, and then pass the statement into an eval statement. I know evals are evil, but I can&amp;rsquo;t find a way in Python to dynamically change the signature of the original method and make it accept a variable length argument (varargs).&lt;/p&gt;

&lt;p&gt;So this is it. It&amp;rsquo;s quite simple. Python methods can have varargs and keyword args, the situation gets a little more complicated. The thing is, both varargs and keyword args are not mandatory, so it&amp;rsquo;s hard for the curried function to know whether the argument list has been completed&amp;hellip;Also, if you take default values into account, it could get even more complicated.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use delegation to write map/filter in Java</title>
      <link>http://blog.idempotent.ca/2010/03/01/use-delegation-to-write-map/filter-in-java/</link>
      <pubDate>Mon, 01 Mar 2010 19:32:00 +0000</pubDate>
      
      <guid>http://blog.idempotent.ca/2010/03/01/use-delegation-to-write-map/filter-in-java/</guid>
      <description>

&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;

&lt;p&gt;In Java, imagine you have a list of &lt;code&gt;User&lt;/code&gt; objects, each encapsulates the user&amp;rsquo;s &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;first name&lt;/code&gt;, &lt;code&gt;last name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt;. Then you want to call a web service &lt;code&gt;UserService.deleteUsersByIds(List&amp;lt;Integer&amp;gt; userIds)&lt;/code&gt; to delete the users from your data store. It doesn&amp;rsquo;t sound too hard, does it? All you need to do is to transform you &lt;code&gt;List&amp;lt;User&amp;gt;&lt;/code&gt; to &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;. So you go ahead and write the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; ids = new ArrayList&amp;lt;Integer&amp;gt;(users.size());
for (User user : users) {
  ids.append(user.getId());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you go ahead and use your &lt;code&gt;ids&lt;/code&gt; list, and everything is fine and dandy.&lt;/p&gt;

&lt;p&gt;However, two minutes later, you find yourself having to provide another API method with a list of user&amp;rsquo;s names in String. So, again, you exercise your &lt;em&gt;CSC101&lt;/em&gt; skill:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; names = new ArrayList&amp;lt;String&amp;gt;(users.size());
for (User user : users) {
  names.append(new StringBuilder(user.getFirstName()).append(&amp;quot; &amp;quot;).append(&amp;quot;user.getLastName()));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, something else comes along and you need to write a piece of code that returns a list of names that belong to people who are under 21 years of age in the list&amp;hellip;You get the idea. Well, things get boring pretty quickly.&lt;/p&gt;

&lt;p&gt;As it turns out, these are two very important functions in &lt;a href=&#34;http://en.wikipedia.org/wiki/Functional_programming&#34;&gt;functional programming&lt;/a&gt; map and filter.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map(coll, f)&lt;/code&gt; &amp;ldquo;loops&amp;rdquo; over the collection, calls the function f on each element, and add the return of the &lt;code&gt;f(element)&lt;/code&gt; to the return collection.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filter(coll, f)&lt;/code&gt; &amp;ldquo;loops&amp;rdquo; over the collection, calls &lt;code&gt;f(element)&lt;/code&gt;, and only add element to the return list when &lt;code&gt;f(element)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;use-delegation-for-generic-ity&#34;&gt;Use delegation for generic-ity&lt;/h2&gt;

&lt;p&gt;Now we take our first step in designing our generic map function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;FromType, ToType&amp;gt; List&amp;lt;ToType&amp;gt; map(ArrayList&amp;lt;FromType&amp;gt; list) {
  List&amp;lt;ToType&amp;gt; retval = new ArrayList&amp;lt;ToType&amp;gt;(list.size());
  for (FromType item : list) {
    [...]
  }
  return retval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we left out in the above code snippet is how the input is mapped to the output. This is where delegates come in. Unfortunately, Java doesn&amp;rsquo;t have the language-level delegate. We need to design an interface for this delegate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface MapDelegate&amp;lt;FromType, ToType&amp;gt; {
  ToType map(FromType obj);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The delegate is parameterized (to provide more type safety) with &lt;code&gt;FromType&lt;/code&gt; and &lt;code&gt;ToType&lt;/code&gt;. &lt;code&gt;FromType&lt;/code&gt; is the type of the objects in the original list, and &lt;code&gt;ToType&lt;/code&gt; is the type of objects in the mapped list. Now we need to change our method signature to incorporate the delegate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;FromType, ToType&amp;gt; List&amp;lt;ToType&amp;gt; map(ArrayList&amp;lt;FromType&amp;gt; list, MapDelegate&amp;lt;FromType, ToType&amp;gt; mapDelegate) {
  List&amp;lt;ToType&amp;gt; retval = new ArrayList&amp;lt;ToType&amp;gt;(list.size());
  for (FromType item : list) {
    retval.add(mapDelegate.map(item));
  }
  return retval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the client code will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;User&amp;gt; users = getUserListFromSomeWhere();
List&amp;lt;String&amp;gt; ids = map(users, new MapDelegate&amp;lt;User,String&amp;gt;() {
  public String map(User obj) {
    return new StringBuilder(user.getFirstName()).append(&amp;quot; &amp;quot;).append(&amp;quot;user.getLastName()).toString();
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, we can write a filter function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; filter(List&amp;lt;T&amp;gt; list, FilterDelegate&amp;lt;T&amp;gt; filterDelegate) {
  List&amp;lt;T&amp;gt; retval = new ArrayList&amp;lt;T&amp;gt;(list.size());
  for (T item : list) {
    if (filterDelegate.filter(item)
      retval.add(item);
  return retval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface FilterDelegate&amp;lt;T&amp;gt; {
  boolean filter(T item);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;what-about-return-value-creation&#34;&gt;What about return value creation?&lt;/h2&gt;

&lt;p&gt;Use delegation, we can separate the parts of an algorithm in terms of their interfaces and leave the implementation to the caller. However, given the above filter and map methods, what if I don&amp;rsquo;t want the return type to be &lt;code&gt;ArrayList&lt;/code&gt;? What if I want a &lt;code&gt;LinkedList&lt;/code&gt; or a &lt;code&gt;HashSet&lt;/code&gt;? Doesn&amp;rsquo;t the statement&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  List&amp;lt;T&amp;gt; retval = new ArrayList&amp;lt;T&amp;gt;(list.size());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;an implementation by itself?&lt;/p&gt;

&lt;p&gt;Absolutely! For more flexibility, the &amp;ldquo;new&amp;rdquo; statement in the implementation body has to be delegated out as well. We introduce a &lt;code&gt;ReturnDelegate&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface ReturnDelegate&amp;lt;R extends Collection&amp;lt;?&amp;gt;&amp;gt; {
  R createReturnCollection();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and plug in the return delegate to the map method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;FromType, ToType, R extends Collection&amp;lt;?&amp;gt;&amp;gt; R map(Collection&amp;lt;FromType&amp;gt; coll, MapDelegate&amp;lt;FromType, ToType&amp;gt; mapDelegate, ReturnDelegate&amp;lt;R&amp;gt; returnDelegate) {
  R retval = returnDelegate.createReturnCollection();
  for (FromType item : list) {
    retval.add(mapDelegate.map(item));
  }
  return retval;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the actual implementation has been completely separated. I know you can probably achieve flexibility without return delegate with the use of reflection, but on some systems (like GWT, which is what I&amp;rsquo;m working on and what this code is originally designed for), reflection is off limits.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>